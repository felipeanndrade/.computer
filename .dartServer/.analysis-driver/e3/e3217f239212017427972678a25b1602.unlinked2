svaluealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kDitherIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDitherOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColors_ditherenableDitheringrawRgbarawStraightRgbarawUnmodifiedpngrgba8888bgra8888_image_debugStackwidthheight	_disposeddisposedebugDisposed
toByteDatadebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage_cachedFrameCount
frameCount_frameCount_cachedRepetitionCountrepetitionCount_repetitionCountgetNextFrame_getNextFramenonZeroevenOdd	intersectunionreverseDifference_constructor_clonefillType_getFillType_setFillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo_arcTo
arcToPoint_arcToPointrelativeArcToPoint_relativeArcToPointaddRect_addRectaddOval_addOvaladdArc_addArc
addPolygon_addPolygonaddRRect	_addRRectaddPath_addPath_addPathWithMatrixextendWithPath_extendWithPath_extendWithPathAndMatrixcloseresetcontains	_containsshift_shift	transform
_transform	getBounds
_getBoundscombine_opcomputeMetricspositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringinnerFilterouterFilter	_initBlur_initColorFilter_initComposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImagecompile_uniformFloatCount_samplerCount_init_shader_builder_floatUniforms_samplerUniforms	trianglestriangleStriptriangleFanpointslinespolygon	_recordersave	saveLayer_saveLayerWithoutBounds
_saveLayerrestoregetSaveCount	translatescale_scalerotateskewclipRect	_clipRect	clipRRect
_clipRRectclipPath	_clipPath	drawColor
_drawColordrawLine	_drawLine	drawPaint
_drawPaintdrawRect	_drawRect	drawRRect
_drawRRect
drawDRRect_drawDRRectdrawOval	_drawOval
drawCircle_drawCircledrawArc_drawArcdrawPath	_drawPath	drawImage
_drawImagedrawImageRect_drawImageRectdrawImageNine_drawImageNinedrawPicture_drawPicturedrawParagraph
drawPointsdrawRawPoints_drawPointsdrawVertices_drawVertices	drawAtlasdrawRawAtlas
_drawAtlas
drawShadow_drawShadowtoImage_toImageapproximateBytesUsedisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8List_debugDisposedencoded_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixelbytesPerPixelinstantiateCodec_instantiateCodecA_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaintImageByteFormatPixelFormatImage_ImageImageDecoderCallback	FrameInfoCodecinstantiateImageCodecdecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayerPathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgram_FragmentShader
VertexModeVertices	PointModeClipOpCanvasPicturePictureRecorderShadowImmutableBufferImageDescriptor	_Callback_Callbacker	_futurize`dartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintpragmafromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliasByteDataListfilledgrowablegetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmacreator_toNativeColorFilter_toNativeImageFilterfromEnvironmentdefaultValuetoStringStringBufferwritetoStringAsFixed
toByteDatawidgets
StackTracecurrent_handlesadd	_disposedwidthheightvoidcontainsremoveisEmptydispose
StateErrorformatFuturerawRgbamaphandle_debugStacktoList__imageNativeFieldWrapperClass1	Uint8Listcallbackencodedbuffer
asByteDataSetgetNextFramecloneDurationimage	CompletersynccompleteError	ExceptioncompletedurationmillisecondsdurationMillisecondsfuturefromUint8ListallowUpscalingtargetWidthtargetHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPathfrom_clonenonZerolefttoprightbottomzeroradiusrotationlargeArc	clockwise
fromCircleFloat32List_getValue32matrix4fromLTRB_opextractPathIterableforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveTo
collectionIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadow
hashValuescolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashList
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeMatrix4	diagonal3ArgumentErrordatainnerouterinnerFilterouterFiltermirrorrepeateddecalcomposed_shortDescriptionshaderpaintingGradientLinearGradient	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAnglepaint
ByteBufferspirv
debugPrintspvTranspileResult	transpileTargetLanguagesksluniformFloatCountsamplerCountCustomPainterfloatUniformssamplerUniforms_builder_floatUniforms_samplerUniformsdrawVerticestextureCoordinatescolorsindicesany
Uint16ListclipRectSceneendRecordingisRecording_canvascullRectlargest_objects_datasydoAntiAliasclipOparcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraints_paintRSTransform
isNotEmptyscosssintxty
addPicturedrawPicture	_recorder	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleminshadowIndex_kColorDefaultconvertRadiusToSigma_init_initEncodedTtNativeFieldWrapperClass1IterableBaseIteratorImageFilterShader-Sà ú}¨IT¸³ª:Crj   	dart:coreÀ¨â Àu •û <€†€¤€¥€¦€¶€Ç€È_¯‚ ‚P‚‚ïƒ-ƒ0ƒ~ƒ¤ƒ¥ƒå„
„[„¡„í…=…P…Q…p…£…ã…ò…ô…õ††L†††Ÿ† †Å†ü‡V‡e‡g‡h‡”‡Íˆˆlˆ{ˆ}ˆ~ˆ£ˆÚ‰2‰A‰C‰D‰p‰°‰²‰³‰ç‰ëŠ;Š‹ŠÚ‹‹‹6‹:‹F‹m‹©‹àŒŒŒ#ŒtŒÃ?COœäìğşU›©åëDj‘¶¼ZˆÔ‘!‘F‘b‘™‘š‘Ú‘à’-’=’b’‰’¯’µ’ø’ş“I“V“‹“­“Ï“ñ”” ”u”{” ”Ç”í•:•j•p•³•¹––?–u–«–á—#—$—R—X—€—†—®—Ô—û˜ ˜3˜4˜m˜s˜Â˜ä™™™G™M™™À™æ™çššKšLš…š³š´šì›››c›™›Ÿ›×›òœ"œ&œ'œpœ¸œ¾œöJ{€Ğı;T†Š‹ÔŸ
ŸŸHŸcŸ“Ÿ—Ÿ˜Ÿé   T n Ÿ £ ¤ â¡¡=¡]¡¡¢¡£¡î¡ô¢H¢f¢l¢ª¢È££C£€£¼£í£ñ£ò¤!¤'¤o¤²¤¸¥¥O¥¥Ô¥Ú¦'¦q¦¼§§V§¦§ó¨D¨q¨w¨Æ¨æ©©2©G©^©s©‚©ª©²©¿©Ö©øªª&ªjªªªî«0«;«C«I«M«N«‘«×«İ¬)¬p¬»­
­U­•­½­ü®®®B®h®Ÿ®¼®Ê¯¯Z¯¢¯«¯È¯ú°(°H°e°w°Â±±^±g±m±q±r±¿±Å±ğ²#²@²t²x²y²…²¨²È²Û³³³3³T³X³Y³e³‹³Œ³˜³æ³è³é´´ ´m´·´Ö´Úµ+µxµÇ¶¶e¶°¶ô¶ø·H·“·ä¸0¸~¸Ë¹¹]¹¬¹òººº_º¬ºö»H»•»æ¼'¼+¼R¼V¼¤¼å½6½ƒ½Ô¾#¾r¾¾‘¾Ÿ¾£¾î¾ÿ¿¿_¿r¿¸¿¹¿ıÀ @À @?À @EÀ @¢À @«À @¬À @ëÀ @ñÀ A@À AOÀ AUÀ AÀ A–À AñÀ AøÀ AùÀ B8À B>À B‰À BšÀ B À BâÀ BèÀ CCÀ CJÀ CKÀ CˆÀ CÀ CÜÀ D-À DJÀ DPÀ DÀ DËÀ DÑÀ E0À E;À E<À EzÀ E€À E©À E¯À EıÀ FÀ FbÀ FhÀ F·À FâÀ FíÀ FîÀ G6À GƒÀ GĞÀ GŞÀ GäÀ H#À H)À HvÀ H¾À HÎÀ HÔÀ I À I&À IƒÀ IŒÀ IÀ IÚÀ J(À JrÀ JxÀ J²À J¸À KÀ KWÀ K]À K©À K¯À LÀ LÀ LÀ LeÀ L¸À MÀ MÀ MMÀ MSÀ M À MñÀ M÷À NDÀ NJÀ N¨À N²À N³À OÀ OUÀ OŸÀ O¥À OàÀ OæÀ P8À P„À PŠÀ P×À PİÀ Q;À QEÀ QFÀ Q•À QµÀ Q»À R	À RÀ R_À R«À RßÀ RåÀ S0À SAÀ SGÀ S¦À S±À S²À TÀ TÀ T"À TpÀ TvÀ TÆÀ UÀ UAÀ UGÀ U’À U£À U©À VÀ VÀ VÀ VdÀ V˜À VÀ VëÀ VñÀ WLÀ WSÀ WTÀ W“À W™À WèÀ X4À XZÀ X`À X®À X´À YÀ YÀ YÀ YcÀ YiÀ Y¸À ZÀ ZÀ Z^À Z‡À ZÀ ZŞÀ ZäÀ [DÀ [JÀ [ZÀ [`À [¢À [êÀ \À \PÀ \gÀ \sÀ \tÀ \¼À \½À ]À ].À ]4À ]€À ]ÍÀ ]üÀ ^À ^SÀ ^ŸÀ ^ÅÀ ^ËÀ _À _jÀ _»À _ÁÀ `À `2À `8À `–À `œÀ `¬À `²À aÀ aÀ a[À awÀ aÁÀ aØÀ aûÀ aüÀ bEÀ btÀ bzÀ bËÀ cÀ cjÀ c‰À cÀ cÛÀ d(À dWÀ d]À d¼À dÂÀ dÒÀ dØÀ eÀ eXÀ e¨À eÓÀ eŞÀ eßÀ f-À fLÀ fRÀ f›À f¬À f²À gÀ gÀ gÀ gjÀ g‰À gÀ gØÀ géÀ gïÀ hNÀ hYÀ hZÀ h•À h›À hçÀ i4À icÀ iiÀ iËÀ iÙÀ iÚÀ j-À j3À jÀ jÌÀ jûÀ kÀ kbÀ koÀ kpÀ k¹À kãÀ kéÀ l9À l‚À lĞÀ lıÀ mÀ mOÀ mœÀ mËÀ mÑÀ n2À n8À nHÀ nNÀ n‡À nÎÀ oÀ oIÀ oVÀ oWÀ o¥À o½À oÃÀ pÀ pÀ plÀ prÀ p‚À pˆÀ pÁÀ pÎÀ pÏÀ qÀ qÀ qmÀ q„À qŠÀ qÓÀ qäÀ qêÀ r"À r(À rŠÀ r˜À r™À råÀ róÀ rùÀ sHÀ s_À seÀ s®À s¿À sÅÀ sıÀ tÀ tdÀ tqÀ trÀ tÀÀ tÙÀ tßÀ u.À u}À uƒÀ uÏÀ vÀ vdÀ vjÀ v¹À vİÀ vãÀ wCÀ wlÀ wmÀ w¾À w×À wİÀ x&À x,À xuÀ xÅÀ xëÀ xñÀ yLÀ yRÀ ybÀ yhÀ y¸À yáÀ z0À zaÀ zhÀ ziÀ zºÀ zÓÀ zÙÀ {"À {rÀ {ŸÀ {¥À | À |À |À |À |^À |­À |ÃÀ |ÑÀ |ÒÀ }#À }<À }BÀ }‹À }‘À }ÚÀ ~*À ~_À ~eÀ ~ÂÀ ~ÈÀ ~ØÀ ~ŞÀ À bÀ °À ¹À ºÀ €À €$À €*À €sÀ €ÃÀ €ğÀ €öÀ XÀ ^À nÀ tÀ ÃÀ ÙÀ ‚$À ‚=À ‚KÀ ‚MÀ ‚NÀ ‚¦À ‚áÀ ‚åÀ ƒBÀ ƒ‰À ƒÀ ƒâÀ „6À „ŒÀ „àÀ „äÀ …2À …mÀ …qÀ …ÊÀ …ÎÀ †À †cÀ †‚À ††À †”À †˜À †ãÀ ‡À ‡2À ‡OÀ ‡jÀ ‡‰À ‡¨À ‡ÃÀ ‡ØÀ ˆ.À ˆVÀ ˆWÀ ˆ›À ˆ¡À ˆçÀ ‰,À ‰4À ‰5À ‰mÀ ‰sÀ ‰µÀ ‰äÀ ‰ëÀ ‰ìÀ Š6À Š^À ŠdÀ Š¯À ŠüÀ ‹EÀ ‹À ‹–À ‹ÆÀ ‹ÖÀ ‹ÜÀ Œ+À Œ_À ŒtÀ Œ~À ŒÀ ŒÏÀ ŒÜÀ ŒâÀ 0À mÀ sÀ šÀ  À òÀ BÀ À “À ÀÀ ÈÀ ÊÀ ËÀ ïÀ óÀ À À :À }À ºÀ ËÀ À À bÀ ÆÀ ÌÀ ‘À ‘LÀ ‘TÀ ‘UÀ ‘À ‘–À ‘àÀ ’0À ’ À ’¦À ’öÀ “À “$À “%À “hÀ “­À “ÒÀ “ØÀ ”'À ”˜À ”À ”îÀ •À •À •gÀ •‡À •‘À •“À •”À •¾À •ÂÀ –À –SÀ –WÀ –eÀ –iÀ –µÀ –ÁÀ –üÀ —:À —LÀ —‚À —ˆÀ —ñÀ —÷À ˜?À ˜À ˜›À ˜¡À ˜±À ˜·À ™À ™À ™gÀ ™ À ™©À ™ªÀ ™ßÀ ™åÀ šLÀ šRÀ ššÀ šêÀ šöÀ šüÀ ›À ›À ›`À ›qÀ ›zÀ ›{À ›ÉÀ ›ûÀ œÀ œhÀ œnÀ œ¶À À À À (À .À |À À –À ˜À ™À ÓÀ ×À îÀ -À BÀ “À ¡À ¢À èÀ Ÿ.À ŸUÀ Ÿ]À Ÿ^À Ÿ¢À ŸèÀ  /À  mÀ  wÀ  yÀ  zÀ  {À  ªÀ  ¶À  ÌÀ  ÒÀ ¡À ¡nÀ ¡tÀ ¡ÀÀ ¡ÖÀ ¢#À ¢|À ¢ÑÀ ¢êÀ ¢òÀ ¢óÀ £À £%À £~À £¯À £µÀ £õÀ £ûÀ ¤SÀ ¤®À ¤´À ¤ÄÀ ¤ÊÀ ¥&À ¥JÀ ¥VÀ ¥WÀ ¥vÀ ¥|À ¥ÈÀ ¥ÎÀ ¦!À ¦'À ¦nÀ ¦tÀ ¦ÉÀ ¦èÀ §?À §EÀ §UÀ §[À §£À §îÀ ¨À ¨|À ¨‰À ¨ŠÀ ¨ÖÀ ¨ÜÀ ©/À ©À ©ªÀ ©°À ªÀ ªOÀ ª¡À ªóÀ ªùÀ «IÀ «™À «çÀ ¬7À ¬}À ¬ƒÀ ¬“À ¬™À ¬çÀ ­À ­À ­À ­FÀ ­JÀ ­À ­¯À ­½À ­ìÀ ­ñÀ ®<À ®‡À ®ÖÀ ¯$À ¯sÀ ¯xÀ ¯ÈÀ °À °*À °/À °wÀ °xÀ °¬À °­À °ØÀ °ıÀ ±&À ±KÀ ±vÀ ±ŸÀ ±ÉÀ ±ùÀ ²&À ²PÀ ²„À ²´À ²àÀ ³À ³À ³JÀ ³€À ³¾À ³ôÀ ´6À ´tÀ ´´À µ À µFÀ µ†À µØÀ ¶"À ¶dÀ ¶œÀ ¶İÀ ·À ·À ·KÀ ·fÀ ·gÀ ·•À ·éÀ ·íÀ ·îÀ ¸À ¸?À ¸jÀ ¸¾À ¸¿À ¹À ¹À ¹)À ¹DÀ ¹ZÀ ¹`À ¹dÀ ¹eÀ ¹«À ¹¹À ¹¿À ¹×À ¹ğÀ º7À º;À º[À º«À ºÕÀ ºüÀ »@À »DÀ »EÀ »}À »­À »®À »çÀ »íÀ ¼À ¼À ¼#À ¼)À ¼oÀ ¼ À ¼èÀ ¼îÀ ½6À ½KÀ ½_À ½¨À ½ÔÀ ½ØÀ ½óÀ ¾À ¾DÀ ¾‚À ¾†À ¾‡À ¾¿À ¿ À ¿À ¿MÀ ¿SÀ ¿•À ¿æÀ À7À ÀXÀ À^À À«À ÀÌÀ ÀÒÀ ÀùÀ ÀÿÀ ÁÀ ÁÀ ÁdÀ Á˜À ÁâÀ ÁøÀ ÂÀ ÂaÀ ÂœÀ Â À ÂÃÀ ÂŞÀ ÃÀ ÃZÀ Ã^À Ã_À Ã£À Ã©À ÃÑÀ ÃíÀ Ä?À ÄCÀ ÄfÀ ÄÀ Ä¦À ÄäÀ ÄèÀ ÄéÀ Å#À ÅrÀ Å¯À ÅµÀ ÅòÀ ÆÀ ÆQÀ ÆUÀ ÆwÀ Æ’À Æ´À ÆúÀ ÆşÀ ÆÿÀ Ç@À ÇpÀ ÇvÀ Ç¨À ÇÄÀ ÈÀ ÈÀ È=À ÈXÀ È}À È¿À ÈÃÀ ÈÄÀ ÉÀ ÉÀ É\À É§À É­À ÉçÀ ÉíÀ ÊÀ ÊÀ ÊzÀ Ê€À ÊçÀ ÊíÀ ËTÀ ËZÀ Ë¦À Ë÷À ÌÀ Ì	À ÌÀ ÌÀ ÌnÀ ÌšÀ ÌãÀ Í"À Í@À Í”À Í˜À Í½À ÍØÀ ÍıÀ Î@À ÎDÀ ÎEÀ Î}À Î´À ÎµÀ Ï À ÏNÀ Ï™À ÏæÀ Ğ4À Ğ:À ĞÀ Ğ…À ĞÓÀ Ğ÷À ĞıÀ ÑfÀ ÑlÀ ÑÕÀ ÑÛÀ ÒDÀ ÒJÀ Ò–À ÒçÀ ÒóÀ ÒùÀ Ó	À ÓÀ ÓYÀ ÓtÀ Ó½À ÓİÀ Ô&À Ô*À ÔQÀ ÔlÀ ÔªÀ ÔõÀ ÔùÀ ÔúÀ ÕJÀ ÕˆÀ ÕÀ Õ²À ÕÑÀ ÖÀ Ö6À ÖKÀ ÖlÀ ÖŒÀ ÖçÀ ×.À ×9À ×?À ×PÀ ×TÀ ×zÀ ×“À ×åÀ Ø-À ØuÀ Ø‚À ØÏÀ ÙÀ ÙSÀ Ù¬À ÙıÀ ÚÀ ÚÀ ÚÀ ÚZÀ Ú®À ÚúÀ Û À Û(À ÛuÀ Û™À ÛóÀ Û÷À Ü"À Ü=À ÜbÀ Ü¨À Ü¬À Ü­À ÜçÀ ÜíÀ İ#À İ)À İ9À İ?À İ{À İ³À İåÀ Ş-À ŞDÀ ŞtÀ ŞxÀ Ş–À ŞÎÀ ŞÒÀ ŞÓÀ ßÀ ß,À ß2À ßWÀ ß]À ß®À ßÏÀ à&À àHÀ àLÀ àMÀ àuÀ à»À àÛÀ àùÀ á'À á/À á<À á‚À áˆÀ áŒÀ áÀ áÈÀ áÎÀ âÀ â/À â5À âCÀ âaÀ âgÀ â}À âƒÀ â°À âÊÀ âÛÀ âòÀ ã@À ãKÀ ãSÀ ã]À ãcÀ ãsÀ ãyÀ ã´À ãÕÀ ä,À äNÀ äRÀ äSÀ ä{À ä”À ä²À äàÀ äèÀ äõÀ å6À åŒÀ å·À åûÀ æÀ æ	À æÀ æÀ æMÀ æSÀ æŸÀ æéÀ çÀ ç4À ç{À çÀ ç À çêÀ çîÀ çïÀ èÀ èFÀ èJÀ èfÀ è«À è¯À è°À èèÀ èîÀ é:À é€À é³À é¹À éÿÀ ê À ê&À êsÀ ê¿À êâÀ êèÀ ë/À ë}À ë¤À ë¥À ë±À ëÇÀ ìÀ ì4À ì:À ìjÀ ì…À ì¡À ìÊÀ ìèÀ íÀ íBÀ íMÀ ípÀ í—À í¼À íèÀ î#À îxÀ î‡À î­À îµÀ îÍÀ îÓÀ îòÀ ï#À ï;À ïAÀ ïqÀ ï™À ï±À ï·À ïèÀ ğÀ ğ,À ğ2À ğQÀ ğÀ ğ¦À ğ¬À ğÊÀ ñÀ ñÀ ñ#À ñRÀ ñ“À ñ«À ñ±À ñËÀ ñşÀ òÀ òÀ ò;À òxÀ òÀ ò–À ò¬À òåÀ òöÀ ó*À óAÀ ó_À ócÀ óeÀ ófÀ ó¨À óÀÀ ôÀ ô[À ô£À ôíÀ õÀ õÀ õ!À õÀ õŠÀ õ‹À õ«À õ±À ö
À öÀ öÀ ö;À öAÀ ö‘À öÌÀ öİÀ öŞÀ öğÀ ööÀ ÷FÀ ÷”À ÷àÀ ø-À øvÀ ø|À øÍÀ øÙÀ øßÀ øïÀ øõÀ ùTÀ ù™À ù À ù¢À ù£À ùâÀ ùõÀ úCÀ ú“À ú©À úµÀ ú¶À ûÀ ûTÀ ûjÀ ûvÀ ûxÀ ûyÀ û¯À û³À ûóÀ û÷À üEÀ ü]À üaÀ ü°À üÿÀ ıFÀ ıÀ ıÜÀ ıêÀ ıîÀ ş:À ş‰À şĞÀ şÔÀ şâÀ şæÀ ÿTÀ ÿ£À ÿÉÀ À &À ?À OÀ wÀ ŠÀ ”À ³À ·À ¸À ÙÀ õÀÀÀ(À)ÀmÀÀ¬ÀÅÀÉÀÊÀÀÀLÀfÀjÀkÀ…ÀÒÀÀ	ÀZÀuÀ{ÀÆÀÀ`À€À“ÀÀÀìÀÀ9ÀNÀqÀ‰ÀÀ“À”ÀØÀŞÀ,ÀBÀ]ÀqÀÀÀ°ÀºÀ(À,À-ÀbÀhÀ´ÀÄÀÊÀÀ0À€ÀÏÀ	À	eÀ	ºÀ	çÀ
À
À
À
kÀ
À
“À
ÓÀ	À'À7À‹ÀÀ¨À»À¿ÀÀÀñÀ÷ÀFÀ•ÀæÀ2À~ÀÌÀÀ6À<ÀŠÀ³À¹ÀÀRÀhÀnÀ¤ÀªÀ¸ÀÓÀÙÀÀPÀoÀ¹ÀÊÀÜÀüÀLÀšÀÀÀöÀÀ"À*À0ÀRÀ†ÀÑÀüÀ?ÀƒÀÀÀÙÀßÀÀKÀQÀnÀˆÀÀ°ÀÎÀéÀñÀ÷ÀÀ6À<ÀWÀ]À€À¹ÀÃÀÉÀôÀüÀÀÀQÀŸÀÃÀÕÀêÀÀ-À~ÀÌÀÀÀÀ<ÀXÀ\À]À©ÀïÀõÀBÀŒÀÜÀ+ÀuÀÂÀûÀüÀÀ2À4À5ÀOÀÀÈÀãÀèÀ6ÀXÀtÀ‚ÀƒÀ©ÀªÀÒÀÓÀ(À^ÀœÀÌÀÖÀŞÀâÀãÀÀ|À}À—ÀªÀÂÀÎÀæÀ3ÀKÀ•ÀÍÀÔÀêÀúÀşÀÿÀ )À *À MÀ NÀ ZÀ ŠÀ ŒÀ À ¿À ûÀ üÀ!0À!4À!pÀ!ŠÀ!À!ØÀ"!À"oÀ"µÀ# À#)À#-À#fÀ#jÀ#vÀ#‚À#¹À#÷À$À$bÀ$­À$ÊÀ%À%5À%VÀ%\À%dÀ%hÀ%~À%‚À%À%›À%ÒÀ&À&PÀ&À&ÛÀ&õÀ'DÀ'ŒÀ'­À'³À'»À'ÍÀ(À(3À(9À(wÀ(“À(ÑÀ(ÒÀ)À)À)TÀ)oÀ)pÀ)qÀ)šÀ) À)èÀ)îÀ*:À*OÀ*QÀ*RÀ*rÀ*vÀ*¾À*ØÀ*ÜÀ+À+1À+KÀ+zÀ+À+ÈÀ+ãÀ+èÀ,!À,?À,[À,hÀ,iÀ,ƒÀ,©À,äÀ-À-À-5À-dÀ-jÀ-À-ÃÀ.À.HÀ.IÀ.qÀ.wÀ.»À.ÁÀ/À/À/YÀ/‰À/´À/üÀ0PÀ0kÀ0àÀ0ïÀ1À18À1zÀ1†À1À1–À1¯À1ÍÀ1ÓÀ1ğÀ1ôÀ1õÀ21À2ŒÀ2À2İÀ3 À3)À3+À3,À3OÀ3SÀ3¢À3òÀ4@À4cÀ4gÀ4¹À5À5@À5DÀ5À5ÙÀ6)À6xÀ6ÄÀ7À7dÀ7¬À7èÀ7ìÀ86À8€À8ĞÀ9À9À9]À9iÀ9À9¢À9¶À9ËÀ9éÀ9ôÀ:@À:ŒÀ:¥À:æÀ;À;À;VÀ;~À;„À;ˆÀ;œÀ;ÂÀ;àÀ< À<À<À<À<QÀ<UÀ<¤À<òÀ=9À=ƒÀ=°À=²À=³À=êÀ>8À>qÀ>«À>ÈÀ>ÊÀ>ËÀ?À?À?VÀ?dÀ?hÀ?´À@À@DÀ@HÀ@“À@İÀA-ÀA|ÀAÈÀBÀBhÀB°ÀBìÀBğÀC:ÀC„ÀCÔÀDÀD,ÀD@ÀDMÀD[ÀDqÀD”ÀD¥ÀD¹ÀDÎÀDìÀDñÀEÀEBÀEFÀEdÀEšÀEÀEŸÀEÇÀEìÀF*ÀF:ÀFPÀFhÀF„ÀF¡ÀFªÀF«ÀFÈÀGÀG8ÀGBÀG‹ÀG·ÀGÁÀGÉÀGÊÀGÛÀGöÀHÀH@ÀHJÀHhÀH¬ÀHÇÀHãÀHîÀIÀI0ÀIPÀIQÀI}ÀI‰ÀIÀI‘ÀI’ÀIßÀIïÀIóÀJ*ÀJ>ÀJˆÀJÀJßÀK.ÀK}ÀK¨ÀK®ÀKæÀKñÀKòÀL4ÀL:ÀL‹ÀLÜÀLâÀMÀM&ÀM(ÀM)ÀMMÀMQÀM_ÀMcÀM²ÀMØÀMíÀN!ÀN'ÀNuÀNÀÀOÀOÀOÀOÀOlÀO†ÀO”ÀOãÀP	ÀPÀP]ÀP«ÀPÅÀPËÀPÛÀQÀQÀQjÀQpÀQ¾ÀR	ÀR>ÀRGÀR’ÀRËÀRÑÀSÀSsÀSyÀS‰ÀSÆÀSÍÀTÀTÀTUÀT ÀTáÀTçÀT÷ÀTıÀUFÀU_ÀUtÀUvÀUwÀUÈÀUâÀVÀVaÀV}ÀV™ÀV¬ÀV­ÀVıÀW ÀW&ÀWvÀW¿ÀXÀXYÀXsÀXyÀXÈÀYÀYNÀY}ÀYÀY€ÀY²ÀY¶ÀYûÀYÿÀZBÀZÀZ•ÀZ™ÀZßÀ[
À[À[MÀ[À[¸À[¼À\ À\9À\SÀ\À\©À\ÅÀ\âÀ]À]À]bÀ]§À]³À]´À]ÜÀ]âÀ^/À^~À^¡À^ÇÀ^æÀ^ıÀ_À_2À_3À_qÀ_wÀ_¼À` À`AÀ`BÀ`rÀ`¯À`°À`åÀaÀaÀafÀa°Àa±ÀaøÀbÀb=Àb>Àb…Àb·ÀcÀcÀcEÀc…Àc”ÀcúÀcûÀd>Àd…ÀdÊÀd×ÀeMÀeNÀe“ÀeÚÀeéÀfQÀfRÀf—ÀfŞÀg#Àg8Àg°Àg±Àg÷Àh;Àh€ÀhÇÀhìÀiHÀiIÀiÀiÓÀjÀj_Àj¥ÀjÍÀk9Àk:Àk}ÀkŸÀk¥ÀkèÀlÀlÀlYÀl™ÀlàÀm$ÀmkÀm¯ÀmİÀmãÀn(Àn^Àn°ÀnĞÀo/Ào3ÀowÀoÒÀoÓÀp"ÀpgÀpmÀp¼ÀqÀqIÀqpÀqvÀqÂÀrÀr]ÀrcÀr†Àr§ÀrÂÀrİÀrøÀrÿÀs#ÀsGÀs‹Às±ÀsµÀsøÀt;ÀtxÀtyÀtzÀtÉÀuÀuÀuHÀuNÀuÀuëÀv.ÀvxÀv~ÀvÈÀwÀwcÀwzÀwªÀwËÀwæÀxÀxÀx#ÀxLÀxpÀx¼ÀxôÀxøÀyCÀyÀy¹ÀyöÀy÷Àz>ÀzUÀzqÀz‘ÀzÍÀzÑÀ{.À{/À{qÀ{ŸÀ{¥À{÷À|EÀ|aÀ|À|½À|ÁÀ}À}À}gÀ}¤À}ãÀ~$À~jÀ~®À~òÀ~şÀ?À_À²À¶ÀûÀ€FÀ€GÀ€™À€§À€­À€üÀ!À'ÀnÀ£À¿ÀñÀõÀ‚BÀ‚CÀ‚…À‚ÈÀ‚ØÀ‚÷ÀƒÀƒ=ÀƒAÀƒ}Àƒ~ÀƒÄÀƒÊÀ„À„eÀ„À„ÓÀ…À…7À…RÀ…zÀ…¹À…ÆÀ…òÀ…øÀ…üÀ†DÀ†´À†µÀ†ûÀ‡:À‡wÀ‡}À‡ÊÀˆÀˆFÀˆÀˆĞÀˆôÀ‰À‰7À‰|À‰‰À‰¼À‰ÂÀ‰ÆÀŠÀŠ˜ÀŠ™ÀŠŞÀ‹À‹CÀ‹DÀ‹‰À‹ÍÀ‹èÀŒÀŒÀŒ]ÀŒªÀŒÉÀŒÏÀÀÀbÀ‚À¥ÀÏÀÓÀÀÀQÀ€ÀÀÂÀâÀ
ÀÀÀfÀgÀ§À×ÀÿÀ%ÀEÀdÀuÀyÀÇÀÈÀıÀ‘À‘SÀ‘ À‘ëÀ’*À’0À’À’ĞÀ“"À“oÀ“¹À”À”À”ZÀ”oÀ”šÀ”ØÀ”ÜÀ•À•À•]À•pÀ•vÀ•ÆÀ–À–NÀ–—À–²À–ÍÀ–ëÀ—À—1À—7À—®À—²À—öÀ—÷À˜FÀ˜wÀ˜}À˜ÉÀ™À™`À™¯À™ùÀš1Àš7Àš‚ÀšÏÀ›À›LÀ›RÀ›¢À›ïÀœ?Àœ‚ÀœÏÀÀkÀ»À
ÀÀ^À­ÀáÀçÀŸ8ÀŸƒÀŸ¾ÀŸëÀŸïÀŸñÀŸòÀ 4À 8À FÀ ¤À ´À åÀ ëÀ¡À¡=À¡]À¡{À¡|À¡ÁÀ¡ÇÀ¢À¢HÀ¢…À¢ÍÀ¢ÑÀ¢ÒÀ¢ñÀ¢÷À£JÀ£À£§À£¨À£ÕÀ£ÛÀ¤,À¤~À¤šÀ¤±À¤²À¤âÀ¤èÀ¥8À¥‡À¥£À¥©À¥÷À¦FÀ¦•À¦ãÀ¦ôÀ§9À§rÀ§tÀ§uÀ§½À§ÁÀ¨À¨^À¨¤À¨¨À¨îÀ¨òÀ©>À©À©«À©¯À©ùÀªIÀªjÀªªÀªÙÀ« À«!À«IÀ«JÀ«VÀ«ˆÀ«ŠÀ«‹À«ÚÀ«ôÀ¬/À¬yÀ¬zÀ¬•À¬²À¬³À¬¿À¬ÚÀ­À­.À­FÀ­©À®À®yÀ®‚À®ˆÀ®¢À®¦À®§À®³À®ÇÀ®îÀ¯À¯1À¯7À¯OÀ¯aÀ¯eÀ¯gÀ¯hÀ¯§À¯«À¯óÀ°>À°ŒÀ°°À°´À±À±QÀ±À±íÀ²;À²IÀ²\À²zÀ²šÀ²ØÀ³À³MÀ³NÀ³„À³›À³œÀ³ÁÀ³ÇÀ´À´[À´«À´ÊÀ´áÀ´âÀµÀµÀµcÀµªÀµøÀ¶GÀ¶€À¶†À¶ÔÀ·$À·sÀ·¬À·ÆÀ·ÇÀ·æÀ·çÀ·èÀ¸8À¸_À¸eÀ¸´À¹À¹À¹À¹TÀ¹ZÀ¹ À¹ÒÀºÀºÀºÀºaÀºgÀº©ÀºíÀ»;À»˜À»œÀ»À»©À¼À¼À¼À¼KÀ¼yÀ¼À¼¢À¼õÀ¼öÀ½À½À½²À½¶À½ùÀ½úÀ¾>À¾´À¾÷À¿2À¿NÀ¿aÀ¿nÀ¿„À¿ªÀ¿ÏÀ¿ØÀ¿ŞÀ¿âÀÀ>ÀÀ?ÀÀŸÀÁÀÁ5ÀÁ‰ÀÁšÀÁÀÂ,ÀÂ-ÀÂQÀÂÇÀÂëÀÂïÀÃ1ÀÃ2ÀÃ]ÀÃbÀÃ·ÀÃáÀÃùÀÄ%ÀÄ5ÀÄRÀÄXÀÄiÀÄmÀÄ«ÀÄ¬ÀÄøÀÄşÀÅ?ÀÅ_ÀÅaÀÅbÀÅ—ÀÅÓÀÅäÀÆÀÆÀÆjÀÆ­ÀÆ·ÀÆ¸ÀÇÀÇRÀÇ€ÀÇ‰ÀÇŠÀÇ×ÀÈ(ÀÈkÀÈtÀÈuÀÈÅÀÈÓÀÈÜÀÈŞÀÈßÀÉ,ÀÉ|ÀÉÀÉ’ÀÉãÀÉöÀÊAÀÊGÀÊ{ÀÊÀÊÒÀÊØÀË'ÀËuÀËÅÀËÖÀËÜÀÌ+ÀÌ1ÀÌWÀÌ]ÀÌmÀÌsÀÌÀÀÌÙÀÌêÀÌûÀÍÀÍ7ÀÍ8ÀÍRÀÍiÀÍjÀÍ ÀÍëÀÎÀÎKÀÎLÀÎXÀÎ{ÀÎšÀÎ¼ÀÎßÀÎãÀÎäÀÎğÀÏ"ÀÏ#ÀÏ/ÀÏ€ÀÏ‚ÀÏƒÀÏÔÀĞ#ÀĞqÀĞ½ÀĞîÀĞòÀÑ;ÀÑHÀÑsÀÑÀÀÒÀÒUÀÒ[ÀÒ¬ÀÒúÀÓ'ÀÓbÀÓzÀÓšÀÓ²ÀÓÎÀÓÏÀÔÀÔcÀÔiÀÔ´ÀÔÜÀÔâÀÔğÀÕÀÕNÀÕ}ÀÕ¬ÀÕÛÀÕåÀÕëÀÖ:ÀÖ†ÀÖŒÀÖ–ÀÖÖÀÖíÀ×À×À×2À×<À×FÀ×LÀ×^À×dÀ×…À×‹À×•À×ÓÀ×ïÀØÀØ'ÀØCÀØMÀØWÀØ]ÀØäÀØêÀØôÀÙ1ÀÙTÀÙwÀÙšÀÙ½ÀÙÇÀÙÑÀÙ×ÀÚ`ÀÚfÀÚpÀÚ±ÀÚ×ÀÚıÀÛ#ÀÛIÀÛSÀÛ]ÀÛÀÛ¤ÀÛ¿ÀÛÙÀÛ÷ÀÛøÀÜDÀÜTÀÜ|ÀÜ“ÀÜ®ÀÜÆÀÜïÀÜğÀİ>ÀİYÀİÀİ˜Àİ³ÀİËÀİôÀİõÀŞÀŞ+ÀŞJÀŞ]ÀŞ^ÀŞ—ÀŞÌÀßÀßYÀß¢Àß£ÀßÄÀßĞÀàÀàÀàGÀà\ÀàsÀà§Àà¾ÀàÈÀàğÀá	Àá(Àá?ÀáIÀá–ÀáÀÀáäÀâÀâ=ÀârÀâÀâÃÀâÉÀâÍÀâÎÀâÚÀâıÀã'Àã;Àã[Àã{Àã²ÀãÔÀãÿÀäÀäÀäÀä`ÀäaÀämÀäÀä£ÀäºÀäóÀåÀå;Àå_Àå‘ÀåµÀåçÀåöÀæÀæ!Àæ%Àæ&Àæ2ÀæHÀæ]ÀætÀæ­ÀæÆÀæõÀçÀçKÀçoÀç¡Àç°ÀèMÀèSÀèWÀèYÀèZÀè˜ÀèœÀèìÀé7Àé‰ÀéŸÀéÕÀé÷ÀêÀêNÀêbÀê£Àê§Àê¨ÀêÌÀêëÀë%Àë9ÀërÀëvÀë¥ÀëÄÀì	ÀìÀì;Àì?Àì@ÀìoÀìÀìÓÀìçÀíÀí	Àí
ÀíXÀí~Àí›ÀíœÀíÔÀîÀîfÀî²ÀîşÀï ÀïÀï4Àï8ÀïFÀïJÀï™ÀïæÀğ5Àğ]Àğ©ÀğÔÀğñÀñ-ÀñœÀñ¸ÀñÔÀñòÀòKÀòOÀòPÀò”ÀòšÀòèÀó2ÀódÀó°ÀóÍÀóğÀôÀôLÀô®Àô²Àô³ÀôıÀõÀõRÀõ‰Àõ®Àö
Àö7ÀöÀöƒÀö„ÀöÕÀ÷"À÷IÀ÷JÀ÷“À÷ËÀ÷ëÀ÷íÀ÷îÀø ÀøkÀølÀø†Àø«Àø¬ÀøÍÀùÀùÀùTÀùUÀùaÀù¤Àù¥Àù±ÀùõÀùöÀúÀú%ÀúOÀúcÀúŠÀúºÀúìÀúğÀúñÀúıÀû>Àû@ÀûAÀûyÀûİÀûŞÀûõÀüÀü'Àü(Àü<Àü~ÀüŠÀüÁÀüÂÀüİÀüôÀıÀıLÀı}Àı¨Àı®Àı²Àı³Àı¿Àş	Àş
ÀşÀşaÀşbÀşnÀş‘Àş»ÀşÏÀşüÀÿÀÿ@ÀÿgÀÿkÀÿlÀÿxÀÿªÀÿ¬Àÿ­ÀÿàÀ 1À 2À SÀ tÀ uÀ ’À ØÀ äÀÀÀ(À’À“ÀŸÀõÀöÀÀ%ÀOÀcÀ‹À·ÀäÀèÀéÀõÀ1À3À4ÀsÀwÀÇÀÀ^À”ÀÌÀÍÀ	À>À\ÀŸÀ³À÷ÀûÀWÀXÀœÀ¢ÀğÀ:ÀkÀ‰ÀÌÀîÀ,À@ÀzÀ~ÀÚÀÛÀ	À	@À	^À	¡À	µÀ	ûÀ
À
#À
|À
}À
°À
äÀÀEÀYÀ¯ÀÀ?ÀCÀ´ÀÀ(ÀEÀGÀHÀÀÃÀóÀ=ÀYÀuÀƒÀ…À†ÀÛÀôÀøÀEÀ“ÀàÀ0À4À‰ÀİÀ6ÀÀáÀ
ÀÀhÀÀ‘ÀŸÀ£ÀçÀ1ÀÀ«ÀõÀ=ÀdÀ±ÀÿÀÀTÀdÀ¾ÀÄÀÀVÀ\À´ÀÔÀÚÀ=À ÀÀÀÀ]ÀcÀ»ÀÀEÀKÀ¥ÀÀÀnÀÔÀ9ÀEÀFÀ™ÀŸÀ÷ÀOÀ¥ÀÀÀÆÀ ÀvÀ‹À‘ÀõÀYÀ¼ÀÆÀÇÀÀÀgÀÂÀÒÀØÀ 1À QÀ WÀ ºÀ!À!À!ˆÀ!ŠÀ!‹À!¼À!äÀ"À"=À"^À"oÀ"qÀ"rÀ"¦À"ÀÀ"èÀ#"À#KÀ#iÀ#ŒÀ#°À#ÓÀ#òÀ$À$À$&À$(À$)À$fÀ$ˆÀ$ªÀ$×À$ğÀ%	À%"À%;À%LÀ%NÀ%OÀ%—À%›À%íÀ& À&À&À&À&ŒÀ&À&°À&±À&æÀ&çÀ'À'"À'qÀ'ÂÀ(À(AÀ(GÀ(–À(ÌÀ(ÒÀ)5À)˜À)üÀ*bÀ*hÀ*³À*ùÀ+À+À+gÀ+ºÀ+úÀ,À,À,-À,GÀ,eÀ,À,§À,ÌÀ,ïÀ-À-/À-kÀ-~À-«À-ïÀ.,À.”À.¨À/À/À/À/ŸÀ/êÀ0
À0À0_À0°À0úÀ1/À15À1ƒÀ1¹À1¿À2"À2…À2éÀ3OÀ3UÀ3¦À3ìÀ4À4À4ZÀ4­À4íÀ4óÀ5?À5À5×À6%À6tÀ6™À6¬À6¿À6ÒÀ6ìÀ7
À72À7LÀ7_À7|À7£À7ÂÀ7ãÀ8À82À8_À8œÀ9À9À9jÀ9ÆÀ:
À: À:ŠÀ:—À; À;À;¢À;¨À;¬À<[À=CÀ=DÀ=”À=²À=¸À>À>QÀ>ŒÀ>’À>áÀ?2À?|À?±À?·À@À@HÀ@NÀ@°ÀAÀAuÀAÚÀAàÀB/ÀBÀB¢ÀB¨ÀBõÀCHÀCˆÀCšÀC­ÀCÇÀCåÀDÀD*ÀDMÀDgÀDÀD­ÀDÎÀDñÀEÀE8ÀEtÀE‡ÀE´ÀEñÀFYÀFmÀFâÀFæÀG§ÀG¨ÀGúÀHÀH6ÀHÀH›ÀHÉÀI%ÀI+ÀI/ÀI1ÀI2ÀIpÀI“ÀIãÀJ/ÀJ{ÀJÌÀKÀKpÀKšÀK¶ÀLÀL&ÀL-ÀLoÀLˆÀL¡ÀL¾ÀLÎÀLìÀM*ÀM>ÀM›ÀMŸÀM×ÀN^ÀN`ÀNaÀNÑÀNÕÀOÀOPÀOTÀOÌÀOĞÀP	ÀP
ÀPNÀPTÀP¢ÀPñÀQÀQ!ÀQÀQâÀRÀR,ÀRIÀRPÀR³ÀR·ÀR¸ÀRÔÀRêÀS	ÀS&ÀS-ÀSAÀSwÀS„ÀS£ÀSªÀSÍÀT ÀT)ÀT-ÀT.ÀTSÀTsÀTtÀT°ÀTúÀTûÀUFÀU`ÀUfÀU±ÀUåÀUëÀV5ÀVvÀV|ÀVÍÀWÀWPÀWVÀW‰ÀWÀW™ÀWÆÀWòÀXÀXLÀXVÀX\ÀX«ÀXôÀXúÀYXÀY^ÀY‰ÀYÀYšÀYªÀY½ÀYøÀYşÀZYÀZœÀZ¢ÀZÕÀZÛÀZåÀ[À[GÀ[QÀ[WÀ[ À[¬À[²À[ıÀ\:À\LÀ\lÀ\”À\›À\¼À\óÀ\ùÀ]/À]JÀ]¾À]ÄÀ^)À^wÀ^}À^ À^ÉÀ^ÖÀ_À_À_KÀ_À_ÅÀ_ØÀ_ÜÀ_İÀ_íÀ`	À`(À`OÀ`tÀ`vÀ`wÀ`‘À`¸ÀaÀaÀa#ÀaaÀatÀa‡Àa Àa»ÀaÌÀaÍÀaïÀbÀb?Àb@ÀbLÀboÀbÀb¢ÀbÌÀbàÀcÀc*ÀcoÀc¾ÀcÂÀcÃÀcÏÀd1Àd3Àd4Àd…Àd‰Àd¬ÀdóÀeÀeMÀeZÀe[Àe©ÀeºÀe»ÀfÀf*Àf,Àf-ÀfeÀf—ÀfŞÀfäÀg"ÀgmÀgsÀgÄÀgíÀgóÀh.ÀhWÀhÀhØÀhŞÀi+ÀiUÀišÀi¦Ài»ÀiÙÀiÿÀjÀj0ÀjMÀjpÀjÅÀkÀkYÀk¤Àk÷ÀlSÀlTÀlšÀlêÀmÀm%ÀmYÀmzÀmˆÀm¿ÀmäÀmòÀmóÀnaÀn£Àn§Àn¨ÀnøÀo,ÀohÀo¢ÀoãÀoéÀpÀpÀpfÀp«ÀpÆÀpÌÀqÀqfÀqyÀq´ÀqİÀrÀr^ÀrdÀrµÀs ÀsÀsÀsZÀs„ÀsÉÀsÙÀsîÀtÀt0ÀtGÀt`Àt}Àt ÀtõÀuLÀuÀuØÀv+Àv‡ÀvˆÀvÚÀwÀw Àw!ÀwDÀw[ÀwÀw­ÀwÍÀxÀx	Àx
ÀxXÀx\Àx}ÀxÁÀxÒÀxôÀxúÀyHÀy’ÀyËÀyÑÀzÀzmÀzƒÀzÀzÀzÈÀzÎÀ{À{À{\À{rÀ{{À{|À{±À{·À{ùÀ|À|À|À|À|gÀ|sÀ|wÀ|–À|¤À|ÜÀ|êÀ|ëÀ}$À}1À}3À}4À}iÀ}mÀ}´À}øÀ~9À~=À~†À~ÖÀÀ<À@ÀÀÙÀ€À€À€_À€À€ÎÀÀ/À5À~ÀÆÀ‚À‚eÀ‚²À‚õÀ‚ûÀƒBÀƒXÀƒtÀƒÈÀƒæÀ„CÀ„]À„|À„›À„õÀ„ùÀ…'À…HÀ…hÀ…ŠÀ…ÊÀ…ËÀ†)À†…À†ÊÀ†èÀ†éÀ‡1À‡7À‡cÀ‡iÀ‡yÀ‡À‡ĞÀˆÀˆ)Àˆ*Àˆ{ÀˆÌÀ‰À‰dÀ‰sÀ‰yÀ‰ÅÀŠÀŠdÀŠ¬ÀŠúÀ‹DÀ‹JÀ‹—À‹À‹ÁÀ‹ÇÀŒÀŒaÀŒ±ÀÀ&À,ÀzÀÃÀÀbÀ°À ÀHÀuÀ{ÀÅÀŞÀäÀòÀÀGÀ^À¢ÀËÀ‘À‘CÀ‘]À‘wÀ‘À‘‰À‘À‘ŞÀ’,À’zÀ’˜À’À’¬À’ÙÀ“À“DÀ“[À“ŸÀ“ÚÀ”À”1À”9À”CÀ”IÀ”šÀ”àÀ•*À•0À•>À•kÀ•‚À•ÚÀ–À–1À–HÀ–­À–êÀ—À—À—À—À—gÀ—°À˜À˜9À˜?À˜cÀ˜iÀ˜¨À˜®À˜üÀ™JÀ™›À™æÀš5ÀšƒÀšÎÀ›À›jÀ›»À›ÖÀ›ÜÀ›ìÀ›òÀœBÀœdÀœ¬ÀœÂÀœğÀÀ%ÀaÀnÀ’ÀÙÀÀÀÀbÀÀ¯ÀÍÀíÀŸÀŸ=ÀŸ~ÀŸÀŸ¿ÀŸŞÀŸäÀ #À )À wÀ »À åÀ æÀ¡)À¡nÀ¡µÀ¡êÀ¡ğÀ¢À¢HÀ¢IÀ¢™À¢éÀ£+À£,À£{À£ÅÀ£ÖÀ£ÜÀ¤"À¤4À¤sÀ¤tÀ¤¯À¤°À¥À¥;À¥<À¥À¥ÙÀ¦(À¦QÀ¦‰À¦ŠÀ¦ÚÀ§À§=À§ZÀ§xÀ§¶À§ÏÀ§ÓÀ¨À¨À¨dÀ¨{À¨À¨ÅÀ¨ËÀ©À©eÀ©À©”À©ŞÀ©òÀªNÀªnÀªŠÀª«À«À«À«%À«BÀ«aÀ«À«À«ÛÀ«ÜÀ¬*À¬IÀ¬OÀ¬“À¬™À¬ëÀ­3À­ƒÀ­¾À­àÀ®À®3À®7À®‰À®ŠÀ®ØÀ®ìÀ®òÀ¯6À¯<À¯À¯ÖÀ¯ÿÀ°7À°wÀ°˜À°ºÀ°¾À±À±À±JÀ±–À±³À±èÀ²À²"À²PÀ²TÀ²›À²œÀ²ëÀ³3À³9À³‡À³¼À³ÜÀ³üÀ´À´_À´cÀ´À´›À´·À´ÓÀµÀµ@ÀµAÀµpÀµvÀµ»ÀµÖÀµöÀ¶À¶>À¶BÀ¶ À¶¡À¶ñÀ·,À·VÀ·vÀ·‘À·ÍÀ·ùÀ·ıÀ¸À¸8À¸WÀ¸wÀ¸¥À¸äÀ¸åÀ¹6À¹xÀ¹¥À¹ÇÀ¹âÀº$Àº(ÀºMÀº|Àº½Àº¾À»À»^À»„À»ŠÀ»ÏÀ¼
À¼,À¼NÀ¼iÀ¼ÁÀ¼ÅÀ¼ëÀ½À½AÀ½„À½…À½ÒÀ¾#À¾FÀ¾pÀ¾À¾«À¾çÀ¿À¿À¿5À¿RÀ¿qÀ¿‘À¿¿À¿şÀ¿ÿÀÀJÀÀœÀÀëÀÁÀÁHÀÁgÀÁ‚ÀÁÄÀÁÈÀÁåÀÂÀÂ$ÀÂTÀÂ—ÀÂ˜ÀÂÔÀÂÚÀÃÀÃgÀÃ±ÀÄÀÄVÀÄ¦ÀÄÒÀÄØÀÅ0ÀÅÀÅ¯ÀÅÊÀÆÀÆSÀÆWÀÆtÀÆÀÆ®ÀÆÍÀÆğÀÇÀÇ3ÀÇ`ÀÇÀÇÀÇÓÀÇÙÀÈ"ÀÈkÀÈ—ÀÈÁÀÉÀÉÀÉNÀÉRÀÉnÀÉœÀÉÛÀÉÜÀÊ*ÀÊÀÊ½ÀÊÿÀË#ÀË>ÀËªÀË®ÀËÎÀËêÀÌÀÌ5ÀÌ[ÀÌ ÀÌ¡ÀÌğÀÍ<ÀÍBÀÍ‘ÀÍªÀÍ°ÀÍüÀÎEÀÎXÀÎÀÎßÀÎşÀÏÀÏ8ÀÏYÀÏvÀÏ’ÀÏ°ÀÏÏÀÏìÀĞÀĞ&ÀĞEÀĞhÀĞˆÀĞ·ÀĞ»ÀĞßÀÑÀÑ*ÀÑQÀÑyÀÑŸÀÑÄÀÑëÀÒÀÒFÀÒpÀÒ½ÀÒ¾ÀÓÀÓÀÓYÀÓ§ÀÓôÀÔAÀÔ„ÀÔŠÀÔØÀÕ%ÀÕsÀÕºÀÕËÀÖÀÖUÀÖwÀÖ–ÀÖ±ÀÖÒÀÖòÀ×À×2À×TÀ×qÀ×À×«À×ÊÀ×íÀØÀØ<ÀØ@ÀØdÀØÀØµÀØßÀÙ
ÀÙ0ÀÙUÀÙ|ÀÙ¤ÀÙ×ÀÚÀÚNÀÚOÀÚ–ÀÚ¯ÀÚÕÀÛÀÛ6ÀÛ:ÀÛ|ÀÛ}ÀÛÉÀÛÙÀÛßÀÜ*ÀÜ7ÀÜ=ÀÜ‰ÀÜÖÀİÀİÀİiÀİµÀİ»ÀŞÀŞYÀŞ¦ÀŞ¬ÀŞöÀßBÀßÀßÊÀßéÀàÀà?ÀàCÀàDÀà‰ÀàÀàÖÀàÜÀàìÀàòÀáBÀá[Àá¦ÀáÅÀááÀáüÀâUÀâYÀâZÀâŸÀâ¥ÀâõÀãBÀãHÀãXÀã^Àã¬ÀãÊÀäÀä6ÀäRÀämÀäÀäØÀåÀå#Àå$ÀåTÀå{ÀåÀåàÀåáÀæÀæÀæ_Àæ¡ÀæïÀç'ÀçqÀç±ÀçÒÀç÷ÀèGÀè|Àè‚Àè©Àè¯Àè¿ÀéÀé\ÀéƒÀéÕÀê Àê!ÀêiÀê„Àê£ÀêîÀêòÀëÀë>ÀëpÀë·Àë¸ÀëüÀìÀìSÀì¬ÀìÿÀíSÀí‹Àí‘ÀíáÀî2ÀîÀîÓÀï#ÀïwÀïÃÀïÉÀğÀğjÀğ¿ÀñÀñFÀñšÀñèÀò,Àò2Àò…ÀòÔÀóÀómÀóÂÀóÈÀôÀômÀô¶Àô¼ÀõÀõ(Àõ.Àõ<ÀõQÀõdÀõ|Àõ”ÀõœÀõ¢ÀõĞÀö)ÀöGÀöhÀönÀö€Àö¯ÀöĞÀ÷À÷5À÷_À÷~À÷šÀ÷×À÷õÀøÀøYÀø…Àø±ÀøÂÀø×ÀùÀùHÀùoÀùyÀùÀù‹Àù“ÀùÀù£ÀùüÀúÀúÀú%Àú8ÀúPÀúhÀú{Àú”ÀúœÀú¢ÀúĞÀû)ÀûGÀûhÀûnÀû€Àû¯ÀûĞÀüÀü5Àü_ÀüŠÀü¦ÀüãÀıÀıÀıeÀı‘Àı½ÀıÎÀıãÀşÀşTÀşjÀş˜ÀşÌÀşøÀÿÀÿÀÿÀÿÀÿ&Àÿ,ÀÿuÀÿÀÀÿóÀÿùÀ 	À À ]À tÀ ’À ÁÀ äÀ
À1ÀRÀrÀ´ÀÔÀïÀ2ÀMÀNÀvÀÀéÀ4ÀœÀÀäÀ#À$ÀNÀnÀ“À¸ÀİÀÀ5ÀWÀÀÃÀ÷À+ÀQÀvÀÀÅÀËÀÌÀ5ÀvÀ®À¯À¿ÀÀdÀkÀoÀpÀ´ÀºÀ	À	dÀ	·À
À
]À
¯À
æÀ
ìÀ<À„ÀŠÀÛÀÀFÀLÀšÀäÀêÀ6ÀƒÀÓÀÙÀ4ÀEÀKÀYÀnÀÀ™À±À¹À¿ÀíÀFÀdÀ…À‹ÀÀÌÀÀkÀ¼ÀØÀÀgÀŸÀÛÀÀ+À[ÀƒÀ‰ÀâÀ=À—ÀÙÀÀ1ÀnÀ«À·ÀØÀ3À=ÀCÀOÀWÀaÀgÀÀÀÆÀÔÀéÀüÀÀ,À?ÀXÀ`ÀfÀ”ÀíÀÀ,À2ÀDÀsÀÃÀÀcÀÀÄÀÀLÀ„ÀÀÀéÀÀ@ÀhÀnÀÉÀ À{ÀØÀ#ÀiÀ’À¬ÀçÀÀÀcÀÀ·ÀÆÀıÀ4ÀiÀÀ¤ÀşÀXÀ°À÷À &À 2À SÀ ¾À ÈÀ ÎÀ ÚÀ âÀ ìÀ òÀ!À!À!UÀ!jÀ!‹À!ºÀ!áÀ"À"2À"VÀ"yÀ"»À"ŞÀ"ùÀ#*À#EÀ#FÀ#nÀ#™À#çÀ$À$aÀ$›À%À%LÀ%MÀ%]À%²À%üÀ&À&À&À&7À&]À&‡À&§À&ÔÀ&ùÀ'À'?À'ƒÀ'„À'ÑÀ'×À('À(<À(BÀ(hÀ(ÀÀ) À)À)DÀ)ˆÀ)ŒÀ)ªÀ)ÈÀ)íÀ*6À*8À*9À*À*…À*¹À*½À+À+FÀ+ˆÀ+¢À+ÓÀ,À,9À,?À,uÀ,‘À, À,¡À,ËÀ,ÑÀ- À-oÀ-¸À-¾À.
À.NÀ.À.—À.ºÀ.îÀ/À/TÀ/qÀ/‹À/œÀ/ÀÀ/ÊÀ/ÔÀ/ÛÀ/ßÀ/àÀ0AÀ0BÀ0’À0µÀ0ÈÀ0àÀ0ğÀ1À1À1%À15À19À1:À1fÀ1gÀ1hÀ1‚À1ÈÀ1ÎÀ2À22À2MÀ2aÀ2qÀ2À2 À2ªÀ3À3À3À3hÀ3nÀ3¿À3ñÀ44À46À47À4~À4‚À4ÇÀ5À5EÀ5†À5ÍÀ5éÀ6À6-À6iÀ6jÀ6¥À6«À6ïÀ76À7mÀ7²À7îÀ8À8À8IÀ8OÀ8šÀ8êÀ9/À9JÀ9cÀ9§À9ĞÀ9ìÀ:À:À:3À:7À:8À:ˆÀ:‰À:œÀ:À:ŸÀ:´À:¸À:ôÀ;À;À;#À;nÀ;¹À;ÓÀ;ÙÀ<À< À<oÀ<ˆÀ<™À<ÇÀ<æÀ=À=>À=}À=ÒÀ=ÓÀ>À>'À>QÀ>|À>£À>ÊÀ>ôÀ>õÀ?%À?+À?}À? À?µÀ?¶À?õÀ?ûÀ@IÀ@•À@×À@îÀ@ïÀAAÀA\ÀA]ÀAÀA•ÀAÈÀAÎÀAûÀBnÀB¤ÀBØÀBÜÀBİÀCÀCÀCRÀCÀCÀCÜÀCâÀDÀDnÀD•ÀD›ÀDßÀE(ÀEwÀE™ÀE­ÀEÀÀEÖÀFÀFÀFÀFpÀF~ÀFÀF±ÀFÅÀFäÀGÀGÀGÀGÀGGÀGMÀG˜ÀGİÀHÀHÀH-ÀHzÀHÄÀIÀI[ÀI©ÀIùÀJFÀJŠÀJÀJßÀJÿÀKÀKLÀKcÀKxÀKÀK¤ÀK³ÀKÔÀKÜÀKéÀL ÀLÀL*ÀLAÀLtÀL«ÀLíÀLøÀM ÀMÀM
ÀMÀMDÀMJÀM’ÀM˜ÀM»ÀN	ÀN ÀN@ÀNSÀNiÀNÀN«ÀNæÀOÀOCÀOxÀOŸÀOÔÀOõÀPÀPÀPÀPÀP<ÀP\ÀPoÀPŠÀPªÀPÌÀP÷ÀPûÀPüÀQÀQEÀQFÀQ’ÀQäÀR ÀR:ÀRSÀRmÀRnÀR«ÀRáÀRâÀRüÀSIÀS{ÀSØÀT5ÀTYÀTuÀT¬ÀT­ÀTèÀU1ÀU2ÀUkÀUšÀU›ÀUÔÀVÀVÀVUÀV‘ÀV¹ÀVÁÀVÇÀVÈÀVàÀVäÀVåÀVñÀW4ÀW6ÀW7ÀW~ÀW‚ÀWÑÀWçÀX ÀXBÀXCÀX‘ÀX¦ÀXçÀY,ÀY^ÀY„ÀY¢ÀY¦ÀYüÀYıÀZ1ÀZEÀZFÀZeÀZfÀZÀZ•ÀZæÀ[À[À[)À[JÀ[]À[gÀ[|À[€À[À[ÑÀ[ôÀ[úÀ\GÀ\‘À\ŞÀ]+À]yÀ]—À]ªÀ]ºÀ]ÙÀ]öÀ^	À^À^#À^'À^(À^\À^^À^_À^ªÀ^®À^ıÀ_À_NÀ_eÀ_fÀ_±À_ôÀ`0À`bÀ`šÀ`ºÀ`¾Àa-Àa.ÀagÀamÀa¹ÀaÉÀaÏÀbÀbpÀb±ÀbîÀcÀc#Àc;ÀcTÀcgÀcÀc”Àc¨Àc¾ÀdÀdÀdiÀdmÀeÀeÀeÀeNÀexÀe~Àe¹ÀeäÀeåÀeõÀf)ÀfTÀfZÀf•ÀfÃÀfÄÀfÛÀgÀgOÀgUÀgŒÀgÏÀgĞÀh ÀhCÀhvÀhwÀhÅÀháÀhçÀi2ÀiÀiÀi–ÀiäÀjÀj\ÀjÀj©Àj¯ÀjäÀjÿÀkÀkÀk=ÀkXÀkuÀk³ÀkòÀlÀlSÀltÀlªÀl°ÀlÑÀlóÀlôÀmÀmRÀmdÀmhÀmßÀmáÀmâÀnÀnGÀnHÀn€Àn„ÀnÎÀnÛÀoÀoÀooÀo…Ào‰Ào×ÀoõÀoùÀpFÀpJÀp]ÀpaÀpmÀp¢Àp¦ÀpáÀqÀq#Àq'ÀqGÀqxÀq~Àq†ÀqáÀr=ÀroÀr£ÀrÙÀs ÀsdÀs¡ÀsµÀsáÀsöÀtÀt5ÀtDÀt„ÀtŒÀt™Àt¶Àt¼ÀtÂÀtÒÀtçÀuÀuÀu        !‰³ª4¡„ç/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c = const Color(0xFF42A5F5);
/// Color c = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c = const Color.fromARGB(255, 66, 165, 245);
/// Color c = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. «‚í ‘j‘o‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).‘p	‘u  
‘H‘I‘O‘`‘P‘ƒ‘}‘‹‘…‘‘œ‚‚“c“d“l£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.“m“r  “t“y  “{“€  “‚“‡  -“•“”“—”“ï“Í“«“˜“©“¤“™“¢“œ“š““§“º“Ë“Æ“»“Ä“¾“¼“À“É“Ü“ì“è“İ“æ“à“Ş“â“ë“ş””
“ÿ””” ””””"ƒ –––Ê/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.––  ––$  –&–+  –-–5  3–I–C—–K—–ß–©–s–L–q–l–M–j–d–N–b–^–W–O–Y–a–f–o–ƒ–§–¢–„– –š–…–œ–¥–¹–Ü–Ø–º–Ö–Ğ–»–Ò–Û–ï——–ğ——–ñ————&˜,€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. ˜6€Ü˜î€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   ™€Ï™Í€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   ™éaš(4/// The red channel of this color in an 8 bit value.   šNdš6/// The green channel of this color in an 8 bit value.   š¶bšö5/// The blue channel of this color in an 8 bit value.   ³[/³o   ³[³\›	›ß€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ›é›î   œ)Uœş€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. 
   ‚C€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. KP   	ŸP€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ŸZŸ_   Ÿš \€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects.  e j    ä€½ ò  ¡¡   ¡¥‚K¢³€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   £ô‡X¨ö„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. ¨û©  ©©  ©©   «P† ­dö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. ­o­v  ­­ˆ   ±t±ıw/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. ²²   ²{€Ü²•  ²˜²   ²{²|³W³¡   ³³ À ­À F`À ­µ€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À ¸Á€¢ À ¹À ¹$Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  'À °z0À °‰ À °‘À °™À °©À °šÀ °¯'À °À À °ÕÀ °Ú!À °ë À °úÀ °ÿ%À ± À ±#À ±(!À ±9 À ±HÀ ±M'À ±^ À ±sÀ ±x%À ±‰ À ±œÀ ±¡&À ±² À ±ÆÀ ±Ë,À ±Ü À ±öÀ ±û)À ² À ²#À ²(&À ²9 À ²MÀ ²R0À ²c À ²€À ²†,À ²— À ²°À ²¶(À ²Ç À ²ÜÀ ²â#À ²ó À ³À ³
>À ³ À ³DÀ ³1À ³GÀ ³L2À ³] À ³zÀ ³mÀ ³}À ³‚:À ³“ À ³¸À ³§À ³»À ³À2À ³Ñ À ³îÀ ³áÀ ³ñÀ ³ö>À ´ À ´0À ´À ´3À ´8:À ´I À ´nÀ ´]À ´qÀ ´v<À ´‡ À ´®À ´œÀ ´±À ´¶HÀ ´Ç À ´úÀ ´âÀ ´ıÀ µBÀ µ À µ@À µ+À µCÀ µH<À µY À µ€À µnÀ µƒÀ µˆNÀ µ™ À µÒÀ µ·À µÕÀ µÚFÀ µë À ¶À ¶À ¶À ¶$>À ¶5 À ¶^À ¶KÀ ¶aÀ ¶f4À ¶w À ¶–À ¶ˆÀ ¶™À ¶ß%À ¶ğ À ·À ·MÀ ·\  À ·ğ"À ¸ À ¸À ¸'À ¸' À ¸<À ¸A'À ¸R À ¸gÀ ¸l"À ¸} À ¸À »,À » À »¡À ¾Á=À ¾Ò À ¾çÀ ¾ğÀ ¾ñÀ ¾øÀ ¾ùÀ Î3À Î“ À Î¯À è²‚ğÀ ë‹‚®/// Whether to dither the output when drawing images.
///
/// If false, the default value, dithering will be enabled when the input
/// color depth is higher than the output color depth. For example,
/// drawing an RGB8 image onto an RGB565 canvas.
///
/// This value also controls dithering of [shader]s, which can make
/// gradients appear smoother.
///
/// Whether or not dithering affects the output is implementation defined.
/// Some implementations may choose to ignore this completely, if they're
/// unable to control dithering.
///
/// To ensure that dithering is consistently enabled for your entire
/// application, set this to true before invoking any drawing related code.À ëÀ ¹g€ÓÀ ¹âi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À º=À ºA  À ºM
À ºS   À »°‚'À ½W„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ½Ú€«À ½Ş  À ½äÀ ½ë   À ¿ƒœÀ Â‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Â¢€»À Â¦  À Â°À Â»   À Ãa€áÀ Ãåk/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À ÄE€¢À ÄI  À ÄOÀ Ä^   À ÄëiÀ Åÿ€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À ÆW€¦À Æ[  À ÆgÀ Æo   À ÇÀ Ç¸€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À È€¦À È   À È*À È5   À ÈÆ„ÑÀ Í3„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À Íš€©À Í  À Í©À Íµ   À Î·…rÀ ÓÊ„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Ô,€ÌÀ Ô0  À ÔAÀ ÔI   À Ôü‚WÀ ÕÄ€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À ×V‚°À ×Z  À ×eÀ ×r   À Ú
ìÀ Û‰/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Ûù€²À Ûı  À ÜÀ Ü   À Ü¯ÈÀ Ş;k/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À ŞzWÀ Ş~  À Ş…À Ş   À ŞÕvÀ ßÁ€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À àO<À àS  À à_À àm   À á‚ÂÀ ãÇú/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// import 'dart:ui' as ui;
///
/// ui.Image image;
///
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     image,
///     Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: .5, sigmaY: .5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À äU·À äY  À äeÀ äs   À ænÀ ç%/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À çlÀ ç…  À ç’
À ç˜   À çñXÀ çú    À èLbÀ èP  À èX
À è^   À ·i€ƒÀ ·w    À ë§‡»À ëº   À ë§À ë¨ À ûyŸºÀ „/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À (€À -À .À / À 0À 6   À Û/À À ÛÀ ÜÀ âÀ óÀ ãÀÀ  ÀmÀr À~À+€ÀwA/// The number of image pixels along the image's horizontal axis.   ÀÌ€À?/// The number of image pixels along the image's vertical axis.   À–•ÀM€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À‡ƒÀ‡æ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   À/‚éÀ	y€ô/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. À	…0À	–  À	À	­À	®À
¢À
ç€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   ÀÂŒ™ÀËŠn/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageLoader(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À_‚›ÀÉ‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. ÀÓÀÚ   Àş3À   ÀşÀÿ À5…VÀU  ÀZ'À|À}À~  ÀZÀ[ÀaÀrÀbÀÀ„ ÀÀ ,À 7 À IÀ JÀ BÀ HÀ CÀ…#À    À¬%À´    ÀÕÀç  Àó0À  ÀÀÀÀå€–À)9/// Returns an error message on failure, null on success. À5
À:  ÀAÀX   À™dÀ    À 'À     À P9À c   À PÀ QÀ5À6À<ÀMÀ=À ü‰TÀ'Á†¾/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(Codec codec) async {
///   final FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(Codec codec) async {
///   final FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À'ÏÀ(À(ŸÀ( €»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À(¢À(±  À(ºÀ(É   À(Ô€™À)e{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À)s€ÚÀ*H€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À*RˆØÀ+Q€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec]. À,A&À,bÀ,cÀ,d  À,AÀ,BÀ,HÀ,YÀ,IÀ,kÀ,p  À-À-  À,…^À,³#/// Number of frames in this image.   À,æ.À,î    À-7€ÕÀ-Í€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À.8À.    À.Kƒ¨À///// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À1÷€”À2;9/// Returns an error message on failure, null on success. À2I$À2f   À2€™À3n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À+1À+2À+8À+IÀ+9ÀUw„ÀUèP/// A handle for the framework to hold and retain an engine layer across frames. ÀV€’ÀV¦ÀV§ÀV¨a/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀVÀV€ÀV†ÀV—ÀV‡  ÀV¯‚ÍÀYU‚ˆ/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.   ÀUÈÀUÉÀUÏÀUàÀUĞÀY€À FpÀ\Y‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. À\ƒ^ À\ÇÀ\Ë%/// Create a new empty [Path] object. À\«À\¬À\²À\ÃÀ\³À]€œÀ]­À]®À]¯€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].  À]¶JÀ^ŒÀ^À^‘€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.À^’À^˜    À_5€ÊÀ_Ï€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   À`>À`  À`À`   1À\ä.À\é    À_.À_  À_À_   À`D-À`H    À`t:À`y  À`†À`‹   À`²jÀ`ì2/// Starts a new sub-path at the given coordinate. À`óÀ`û  À`ıÀa   Àa €ÀamE/// Starts a new sub-path at the given offset from the current point. Àa|	Àa„  Àa‡	Àa   Àa³€‰ÀbO/// Adds a straight line segment from the current point to the given
/// point. ÀbÀb  ÀbÀb%   Àb@€ÀÀb¾t/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. ÀbÍ	ÀbÕ  ÀbØ	Àbà   Àc€õÀc›€‹/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1). Àc­	Àcµ  Àc¸	ÀcÀ  ÀcÃ	ÀcË  ÀcÎ	ÀcÖ   ÀcıOÀdŞ€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. Àdø	Àe   Àe	Àe  Àe	Àe  Àe	Àe!   ÀeP Àeğ€”/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2). Àeø	Àf   Àf	Àf  Àf	Àf  Àf	Àf!  Àf$	Àf,  Àf/	Àf7   ÀfT[Àg?€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. ÀgO	ÀgW  ÀgZ	Àgb  Àge	Àgm  Àgp	Àgx  Àg{	Àgƒ  Àg†	Àg   Àg³”Àhó0/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse. Àhû	Ài  Ài	Ài  Ài	Ài  Ài	Ài$  Ài'Ài/   ÀiKíÀjÔw/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. Àjä	Àjì  Àjï	Àj÷  Àjú	Àk  Àk	Àk  ÀkÀk   Àk<ƒöÀneƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. Ànk	Ànq  ÀnvÀn~  Àn‰Àn‘  ÀnœÀn¢   Ào5€œÀo:  ÀoAÀoI  ÀoN
ÀoV  ÀoZÀob  ÀohÀop  Ào…Ào  Ào˜Ào   Ào«Ào±   ÀoÕƒßÀrj‚w/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// ÀruÀr}  ÀrŠÀr’  Àr«Àr³  ÀrÆÀrÌ  ÀráÀrç  ÀršÀr Àr¡Àr½ÀrÖÀròÀs·€ÀÀs¼  ÀsÈÀsĞ  ÀsØÀsà  ÀsèÀsğ  ÀtÀt  ÀtÀt#  Àt,Àt2  ÀtNÀtT   Àt|„{Àw‚ã/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. Àw”Àwœ  Àw®Àw¶  ÀwÏÀw×  ÀwêÀwğ  ÀxÀx  Àw¾ÀwÄÀwÅÀwáÀwúÀxÀxú€ûÀxÿ  ÀyÀy  Ày#Ày+  Ày3Ày;  Ày^Àyf  ÀynÀyv  ÀyšÀy   Ày©Ày¯   Àyù€×Àz\Y/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. Àzd	Àzj   ÀzÓZÀzØ  ÀzáÀzé  Àzî
Àzö  ÀzúÀ{  À{À{   À{1À|L/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À|T	À|Z   À|ÃZÀ|È  À|ÑÀ|Ù  À|Ş
À|æ  À|êÀ|ò  À|øÀ}    À}!‚”ÀÎ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval. À	À  ÀÀ  À*À2   À¸€À½  ÀÅÀÍ  ÀÒ
ÀÚ  ÀŞÀæ  ÀìÀô  À€
À€  À€À€%   À€I«Àu/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. À€À  À•
À›   À÷JÀü  À‚À‚  À‚
À‚"   À‚E€ûÀ‚ß€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. À‚èÀ‚ï   ÀƒC9ÀƒH  ÀƒRÀƒ_   Àƒ€‚{À„—/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. À„Ÿ	À„¥  À„ªÀ„²  À„ºÀ„È   À…şEÀ†  À†	À†  À†	À†  À†"	À†*   À†FmÀ†K  À†^	À†d  À†i	À†q  À†t	À†|  À†À†Œ   À†·ƒÀˆM‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. Àˆ\	Àˆb  ÀˆgÀˆo  ÀˆwÀˆ…   À‰ÈSÀ‰Í  À‰İ	À‰ã  À‰è	À‰ğ  À‰ó	À‰û   ÀŠyÀŠ#  ÀŠ<	ÀŠB  ÀŠG	ÀŠO  ÀŠR	ÀŠZ  ÀŠ]ÀŠj   ÀŠ›€§À‹&€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À‹F€ÅÀ‹ï€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   ÀŒÃÀiF/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. ÀrÀz   ÀÕ:ÀÚ  ÀäÀì  ÀîÀö   ÀÀ‡j/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. ÀÀ•   À!DÀ&  À-À3  À;	ÀC  ÀF	ÀN   ÀiÀŞk/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. ÀèÀõ   À{KÀ€  À‹À‘  À™À¦   ÀÊ„À”aƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   À”Ş1À”ê    À•‚À–\0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. À–dÀ–s  À–}
À–ƒ  À–‰
À–   À—´AÀ—¹  À—½
À—Ã  À—É
À—Ï  À—ÕÀ—Ú   À—ù‡õÀŸ‘‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀŸ¡ÀŸ§  ÀŸ´À\9À\:À\@À\QÀ\AÀŸò‡À ª€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. À ¶€Ä À¡À¡ V/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.À¡!À¡'  À¡0À¡6  À¡CÀ¡IÀ¡ZÀ¡SÀ¡JÀ¡VÀ¡cÀ¡iÀ¡xÀ¡qÀ¡jÀ¡tÀ¡~RÀ¢YÀ¢ZÀ¢c€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.À¢dÀ¢l  À¢uÀ¢}   À¢Ô€ÑÀ£€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. À£ªÀ¤©€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). À¤´‚½À§F‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     À§u„Àªp‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. Àª¬sÀª·Àª¸Àª¹ Àªº	ÀªÀ  ÀªÅÀªË  ÀªçÀªİÀªéÀªûÀªüÀªıÀ«ÀªşÀ«
À«À«À«À«#$À«>  À«L;À«q   À«LÀ«M  À«‹ƒÛÀ«úh/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. À¬1GÀ¬CÀ¬DÀ¬E À¬FÀ¬L  À¬[À¬aÀ¬vÀ¬oÀ¬bÀ¬rÀ¬|À¬ˆ  À¬—À¬¤  À¬µğÀ¬Ğ   À¬µÀ¬¶À®©€»À®º   À®©À®ª À¯hŒ«À²O‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. À²^€îÀ²hÀ²iÀ²j À²kÀ²q  À²€À²†À²—À²À²‡À²“À²§À² À²©À²±À²²À²¸À²ÕÀ²¹À²ÁÀ²ÂÀ²çÀ²ŞÀ²éÀ²ñÀ²òÀ²úÀ³À²ûÀ³À³À³-À³ À³/À³7À³8À³PIÀ³“3/// Return the total length of the current contour. À³AÀ´×!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. À´ä‚àÀ·¸‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. À·ÉÀ·Ü   À·ê‚,À¹«£/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. À¹¿À¹Ç   ÀºÀºô€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. À» À»  À»
À»  À»À»!  À»2À»ŸrÀ»²   À»ŸÀ»  À¼‰KÀ¼  À¼MT À¼MÀ¼Y À¼Z	À¼`  À¼eÀ¼k   ÀÄ®€¯ÀÅE€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.ÀÅ[ÀÅ\ À¼¤PÀ¼©  À¼¶	À¼¼  À¼ÁÀ¼Ç   À¼ø€½À¼ÿ  À½À½   À½¸@À½¿  À½ÇÀ½Ì   À½üåÀ¾  À¾À¾  À¾+À¾3   À¿äYÀ¿ğ  À¿ûÀÀ   ÀÀÀÀ   ÀÀA\ÀÀF  ÀÀRÀÀW  ÀÀdÀÀl  ÀÀr
ÀÀz  ÀÀÀÀ…  ÀÀ–ÀÁ €‹ÀÁ¥  ÀÁ²ÀÁ¸  ÀÁÀÀÁÅ  ÀÁÒÀÁÚ  ÀÁà
ÀÁè  ÀÁíÀÁó  ÀÂÀÂ/€¿ÀÂ4  ÀÂ=ÀÂB   ÀÂñ?ÀÂö  ÀÃ ÀÃ   ÀÃã€‰ÀÃè    ÀÄo;ÀÄt     ÀÈß†¢ÀÉé/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. ÀÉøƒ>ÀÌÒÀÌÓÀÌ×‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.ÀÌİÀÌã  ÀÌîÀÌô  ÀÍÀÍÀÍÀÍÀÍÀÍÀÍÀÍ%ÀÍ4ÀÍ-ÀÍ&ÀÍ0ÀÍ:ÀÍJ  ÀÍTÀÍa  ÀÍíÀÍş ÀÎ
ÀÎÀÎ( ÀÎ4ÀÎæ;ÀÎú   ÀÎæÀÎçÀÎN€”ÀÎh  ÀÎkÀÎs  ÀÎNÀÎOÀÏ%ZÀÏ8   ÀÏ%ÀÏ& ÀÏƒ˜ÕÀÑNÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. ÀÑu‚XÀÓ:ÀÓ;ÀÓ?¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.ÀÓ@ÀÓG  ÀÓMÀÓX  ÀÓqÀÓjÀÓsÀÓÀÓ‚ÀÓÀÓªÀÓ¢ÀÓ¬ÀÓÀÀÓºÀÓÂÀÓÑˆ%ÀÛpÀÛqÀÛw‡/// Construct a color filter that transforms a color by a 5x5 matrix, where
/// the fifth row is implicitly added in an identity configuration.
///
/// Every pixel's color value, repsented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
/// ```text
/// | R' |   | a00 a01 a02 a03 a04 |   | R |
/// | G' |   | a10 a11 a22 a33 a44 |   | G |
/// | B' | = | a20 a21 a22 a33 a44 | * | B |
/// | A' |   | a30 a31 a22 a33 a44 |   | A |
/// | 1  |   |  0   0   0   0   1  |   | 1 |
/// ```
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```ÀÛxÀÛ†  ÀÛœÀÛ•ÀÛÀÛ·ÀÛ¬ÀÛ¹ÀÛÏÀÛÇÀÛÑÀÛçÀÛáÀÛéÀÛú€ôÀÜgÀÜhÀÜyW/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. ÀÜ‹ÀÜ„ÀÜÀÜ¦ÀÜ›ÀÜ¨ÀÜ¾ÀÜ¶ÀÜÀÀÜÔÀÜÎÀÜÖÀÜòÀİlÀİmÀİ~d/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. ÀİÀİ‰Àİ’Àİ«Àİ Àİ­ÀİÃÀİ»ÀİÅÀİÙÀİÓÀİÛÀİ÷ÀŞ  ÀŞÀŞ  ÀŞ-ÀŞA  ÀŞLÀŞV  ÀŞ™ÀŞª ÀŞ·ÀŞÎ!ÀŞß ÀŞîÀß,Àß# Àß=Àß[,Àßl Àß†ÀäYÀä   ÀäÀäÀäcÁÀäz   ÀäcÀädÀßÆVÀßß   ÀßÆÀßÇÀà ‚¬Àà.    ÀâĞ2Àâê  ÀâíÀâõ  ÀâĞÀâÑÀæ(‚.Àæ;   Àæ(Àæ) ÀèZ†¥Àé¥D/// A [ColorFilter] that is backed by a native SkColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. Àé×€ÏÀéãÀéäÀéè ÀééÀéï  ÀéıÀêÀêÀêÀêÀêÀêÀê"ÀêJÀê1Àê#Àê*Àê+Àê4Àê?Àê@Àêª€ËÀê¶Àê·Àê½ Àê¾ÀêÄ  ÀêÒÀêØÀêèÀêáÀêÙÀêäÀêñÀê÷Àë!ÀëÀêøÀêÿÀë Àë	ÀëÀëÀëx€ÆÀë„Àë…Àë– Àë—Àë  Àë«Àë±ÀëÁÀëºÀë²Àë½ÀëÊÀëĞÀìÀëßÀëÑÀëØÀëÙÀëâÀëíÀëîÀìB€ÆÀìNÀìOÀì` ÀìaÀìg  ÀìuÀì{Àì‹Àì„Àì|Àì‡Àì”ÀìšÀìÏÀì©Àì›Àì¢Àì£Àì¬Àì·Àì¸Àí€Àí’o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  Àí5Àí£    ÀíÖGÀíÛ  Àíå	Àíê  ÀíğÀíõ   Àî EÀî%  Àî1Àî>   ÀîhIÀîm    Àî´IÀî¹     ÀïˆëÀğãÒ/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. Àğó[ÀñBÀñCÀñG9/// Creates an image filter that applies a Gaussian blur.ÀñJÀñR  Àñ_Àñg  Àñt"Àñ~  ÀñZÀñoÀñˆÀñÀñ‘ÀòR‚_ÀóGÀóHÀóN€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀóOÀó\  Àó{/ÀóŠ  Àó™Àó¦Àó§ÀôµÍÀõÃÀõÄÀõË€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀõÎÀõä  ÀõêÀö     À÷ÍÀ÷Ø    À÷$$À÷1     À÷îƒQÀ÷ô  Àø"H Àø"Àø4 Àø7ÀøF  ÀøKÀøZ   ÀønÀø€  Àøˆ!Àøœ  ÀøÏ@Àøç ÀøöÀùÀùÀù	ÀùÀù
ÀùWLÀùn   ÀùWÀùXÀúóJÀû   ÀúóÀúôÀù@Àù,   ÀùÀùÀù§MÀùº   Àù§Àù¨Àùø€÷Àú  ÀúÀú  ÀùøÀùù ÀûA„jÀûG  Àû{a Àû{Àû“ Àû–Àû¥  Àû¬Àû»  ÀûÂÀûÑ   ÀûàÀûí  Àû÷Àü  ÀüÀü  Àü>>ÀüV ÀüeÀüqÀürÀüvÀü{ÀüwÀüÄ€íÀüÏ    ÀıµSÀıÌ   ÀıµÀı¶Àÿn;Àÿ‚   ÀÿnÀÿoÀü€@Àü™   Àü€ÀüÀşTÀş   ÀşÀşÀşdÀş~  ÀşÀş‰  ÀşdÀşe Àÿ­ƒ…Àÿ³  ÀÿâN ÀÿâÀÿõ ÀÿøÀ   À À "   À 4À F  À UÀ g  À ”BÀ ¬ À »À ÇÀ ÈÀ ĞÀ ÕÀ ÑÀsÀ5   ÀÀÀëEÀÿ   ÀëÀìÀ Ú@À ó   À ÚÀ ÛÀ•_À¨   À•À–Àø€ïÀ  ÀÀ  ÀøÀù À4ŠÀd)/// An [ImageFilter] that is backed by a native SkImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. ÀÏ+ÀÀÀ9/// Creates an image filter that applies a Gaussian blur.ÀÀ7  	ÀDÀJÀYÀRÀKÀUÀjÀbÀlÀZ‚#ÀHÀIÀO€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀPÀd  	ÀqÀwÀ†ÀÀxÀ‚À—ÀÀ™ÀİEÀ	À	À	+//// Converts a color filter to an image filter.À	,À	9  	À	FÀ	LÀ	[À	TÀ	MÀ	WÀ	lÀ	dÀ	nÀ
ÃÀ
¾À
¿À
Ç0/// Composes `_innerFilter` with `_outerFilter`.À
ÈÀ
İ  	À
êÀ
ğÀ
ÿÀ
øÀ
ñÀ
ûÀÀÀÀ¶€À<o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À–5À›    ÀıYÀ  ÀÀ  ÀÀ#  À*À/   À€YÀ…  À‘À  À¦À«   À
%VÀ
*  À
;À
J   ÀEnÀJ  ÀXÀf  ÀrÀ€    ÀH<ÀÉz/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. Àõ€À}À~Àa/// This class is created by the engine, and should not be instantiated
/// or extended directly. À[À\ÀbÀsÀc    À%O£áÀ&–@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// À&éˆÀ,À,À,„æ/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À,À,  À,"	À,*  À,1À,>  À,KÀ,Z  À,i"À,s  À,‘À,Ÿ  -À,}À,…À,†À,®À,´À,ÉÀ,µÀ,ÃÀ,ÈÀ,ÄÀ,ÓÀ,ÙÀ,ìÀ,ÚÀ,èÀ,ëÀ,éÀ,öÀ,üÀ-À-À,ıÀ-À-À-À-,À-%À-À-(À-6À-<À-hÀ-MÀ-EÀ-=À-HÀ-PÀ-_À-gÀ-`À-rÀ-wÀ-xÀ-yÀ-zÀ/¡Œ
À6£À6¤À6ª†½/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].À6°À6¸  À6ÃÀ6Ë  À6ÖÀ6ã  À6ğÀ6ÿ  À7"À7  À76À7D  À7PÀ7Y  À7cÀ7k  'À7"À7*À7+À7xÀ7ƒÀ7‰À7 À7ŠÀ7˜À7ŸÀ7™À7ªÀ7°À7¿À7¸À7±À7»À7ÉÀ7ÏÀ7àÀ7ÙÀ7ĞÀ7ÜÀ7êÀ7ğÀ8À8À7ùÀ7ñÀ7üÀ8À8À8À8À8&À8+À8,À8-À8.À=F‰ŸÀC’ÀC“ÀC˜†/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.ÀCÀC¦  ÀC±ÀC¾  ÀCËÀCÚ  ÀCé"ÀCó  ÀDÀD  ÀD.ÀD6  ÀDQÀD_  >ÀCıÀDÀDÀD%ÀDHÀD@ÀDDÀDEÀDJÀDnÀDtÀD‹ÀDuÀDƒÀDŠÀD„ÀD•ÀD›ÀDªÀD£ÀDœÀD¦ÀD´ÀDºÀDËÀDÄÀD»ÀDÇÀDÕÀDÛÀDîÀDçÀDÜÀDêÀDøÀDşÀEÀEÀDÿÀEÀEÀEÀE5ÀE+ÀE ÀE-ÀE?ÀEEÀEqÀEVÀENÀEFÀEQÀEYÀEhÀEpÀEiÀE{ÀE€ÀEÀE‚ÀEƒ  À&³2À&¸    À/	€”À/  À/À/'  À/1À/<  À/CÀ/Q  À/\À/a  À/jÀ/x   À;®€¬À;³  À;¿À;Ç  À;ÏÀ;×  À;ßÀ;ç  À;îÀ;ù  À< À<  À<À<  À<'À<5   À<]€åÀ<b  
À<oÀ<w  À<~À<†  À<À<•  À<¡À<©  À<®À<¶  À<»À<Ã  À<ÍÀ<Ø  À<ßÀ<í  À<øÀ<ı  À=À=   ÀFè€¾ÀFí  ÀFøÀG   ÀGÀG  ÀGÀG#  ÀG*ÀG8  ÀGCÀGH  ÀGQÀGY  ÀGdÀGl  ÀGuÀGƒ   ÀGª„ÀG¶  ÀGÊÀG×  ÀGŞÀGí    ÀI2…-ÀIv=/// A shader (as used by [Paint.shader]) that tiles an image. ÀI•„	 ÀK¸ÀKÃø/// Creates an image-tiling shader. The first argument specifies the image to
/// tile. The second and third arguments specify the [TileMode] for the x
/// direction and y direction respectively. The fourth argument gives the
/// matrix to apply to the effect. All the arguments are required and must not
/// be null, except for [filterQuality]. If [filterQuality] is not specified
/// at construction time it will be deduced from the environment where it is used,
/// such as from [Paint.filterQuality].ÀKÄÀKË  ÀKÑÀKÛ  ÀKßÀKé  ÀKíÀKú  ÀLÀL  "ÀKœÀKÀK£ÀK´ÀK¤ÀL1ÀL7ÀLEÀL>ÀL8ÀLAÀLsÀLyÀL…ÀL~ÀLzÀLÀLŒÀL’ÀLÀL—ÀL“ÀLšÀL¥ÀL«ÀL»ÀL´ÀL¬ÀL·ÀLÂÀLÇÀLÈÀLÉÀLÊ  ÀM¡5ÀM¦    ÀMÙ€„ÀMŞ  ÀMíÀMõ  ÀMûÀN   ÀNÀN	  ÀNÀN  ÀN%ÀN2    ÀNa’ÀOÖn/// An instance of [FragmentProgram] creates [Shader] objects (as used by [Paint.shader]) that run SPIR-V code.
///
/// This API is in beta and does not yet work on web.
/// See https://github.com/flutter/flutter/projects/207 for roadmap.
///
/// [A current specification of valid SPIR-V is here.](https://github.com/flutter/engine/blob/main/lib/spirv/README.md)
/// ÀRºrÀRåÀRæÀRç ÀRîÀS  ÀSÀS  ÀRºÀR»ÀRÁÀRÒÀRÂÀSÀT0!ÀT?  ÀTUÀTd   ÀP‚ªÀRÇ/// Creates a fragment program from SPIR-V byte data as an input.
///
/// One instance should be created per SPIR-V input. The constructed object
/// should then be reused via the [shader] method to create [Shader] objects
/// that can be used by [Shader.paint].
///
/// [A current specification of valid SPIR-V is here.](https://github.com/flutter/engine/blob/master/lib/spirv/README.md)
/// SPIR-V not meeting this specification will throw an exception. ÀRÀR&  ÀR0ÀR6  ÀRBÀTv9ÀT{    ÀT²GÀT·  ÀT½ÀTÅ  ÀTÊÀTĞ   ÀTıŠŞÀ\C†Ü/// Constructs a [Shader] object suitable for use by [Paint.shader] with
/// the given uniforms.
///
/// This method is suitable to be called synchronously within a widget's
/// `build` method or from [CustomPainter.paint].
///
/// `floatUniforms` can be passed optionally to initialize the shader's
/// uniforms. If they are not set they will each default to 0.
///
/// When initializing `floatUniforms`, the length of float uniforms must match
/// the total number of floats defined as uniforms in the shader, or an
/// [ArgumentError] will be thrown. Details are below.
///
/// Consider the following snippit of GLSL code.
///
/// ```
/// layout (location = 0) uniform float a;
/// layout (location = 1) uniform vec2 b;
/// layout (location = 2) uniform vec3 c;
/// layout (location = 3) uniform mat2x2 d;
/// ```
///
/// When compiled to SPIR-V and provided to the constructor, `floatUniforms`
/// must have a length of 10. One per float-component of each uniform.
///
/// `program.shader(floatUniforms: Float32List.fromList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));`
///
/// The uniforms will be set as follows:
///
/// a: 1
/// b: [2, 3]
/// c: [4, 5, 6]
/// d: [7, 8, 9, 10] // 2x2 matrix in column-major order
///
/// `imageSamplers` must also be sized correctly, matching the number of UniformConstant
/// variables of type SampledImage specified in the SPIR-V code.
///
/// Consider the following snippit of GLSL code.
///
/// ```
/// layout (location = 0) uniform sampler2D a;
/// layout (location = 1) uniform sampler2D b;
/// ```
///
/// After being compiled to SPIR-V  `imageSamplers` must have a length
/// of 2.
///
/// Once a [Shader] is built, uniform values cannot be changed. Instead,
/// [shader] must be called again with new uniform values. À\PÀ\^  À\p"À\„   À_ß€”À_ä  À_ñÀ`  À`À`  À`,!À`?    À`wƒ»À`—  À`º ÀacÀar€ /// This class is created by the engine and should not be instantiated
/// or extended directly.
///
/// To create a [_FragmentShader], use a [FragmentProgram].ÀaxÀa~  Àa‹Àa‘  Àa¤Àaª  ÀaÁÀaÆÀaÇÀaÈÀaÉÀaÏÀaå  Àañ Àb  Àb(Àb-  ÀcÅkÀcÙ   ÀcÅÀcÆÀbBÀb\  Àb_Àbg  ÀbBÀbCÀ`wÀ`xÀ`~À`À`Àf-‘ÛÀfk7/// A set of vertex data used by [Canvas.drawVertices]. Àf™ˆ ÀiœÀi¤‚â/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The [mode] and [positions] parameters must not be null.
/// The [positions] parameter is a list of triangular mesh vertices(xy).
///
/// If the [textureCoordinates] or [colors] parameters are provided, they must
/// be the same length as [positions].
///
/// The [textureCoordinates] parameter is used to cutout
/// the image set in the image shader.
/// The cut part is applied to the triangular mesh.
/// Note that the [textureCoordinates] are the coordinates on the image.
///
/// If the [indices] parameter is provided, all values in the list must be
/// valid index values for [positions].
/// e.g. The [indices] parameter for a simple triangle is [0,1,2].ÀiªÀi¶  Ài¿ÀiÍ  Àiİ Àiì  ÀjÀj  ÀjÀj(  Àj7Àj=ÀjJÀjCÀj>ÀjFÀjTÀjZÀjlÀjeÀj[ÀjhÀnªˆuÀsÓÀsÔÀs×„ê/// Creates a set of vertex data for use with [Canvas.drawVertices], directly
/// using the encoding methods of [new Vertices].
/// Note that this constructor uses raw typed data lists,
/// so it runs faster than the [Vertices()] constructor
/// because it doesn't require any conversion from Dart lists.
///
/// The [mode] parameter must not be null.
///
/// The [positions] parameter is a list of triangular mesh vertices and
/// is interpreted as a list of repeated pairs of x,y coordinates.
/// It must not be null.
///
/// The [textureCoordinates] list is interpreted as a list of repeated pairs
/// of x,y coordinates, and must be the same length of [positions] if it
/// is not null.
/// The [textureCoordinates] parameter is used to cutout
/// the image set in the image shader.
/// The cut part is applied to the triangular mesh.
/// Note that the [textureCoordinates] are the coordinates on the image.
///
/// The [colors] list is interpreted as a list of ARGB encoded colors, similar
/// to [Color.value]. It must be half length of [positions] if it is not
/// null.
///
/// If the [indices] list is provided, all values in the list must be
/// valid index values for [positions].
/// e.g. The [indices] parameter for a simple triangle is [0,1,2].ÀsİÀsé  ÀsòÀsÿ  ÀtÀt  Àt4Àt@  ÀtKÀtX  ÀtgÀtmÀtzÀtsÀtnÀtvÀt„ÀtŠÀtœÀt•Àt‹Àt˜  Àw#€ãÀw(  Àw.Àw8  ÀwQÀwV  ÀwhÀwu  ÀwŒÀwš  ÀwºÀwÆ  ÀwÚÀwç    À}4À ­À€¤ƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. À€Ğ„( ÀƒvÀƒ|‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.Àƒ}Àƒ  Àƒ™Àƒ   ÀƒZÀƒ[ÀƒaÀƒrÀƒbÀƒ­Àƒ³ÀƒÄÀƒ½Àƒ´ÀƒÀÀ†ÌÀ†İ   ;À„û€ÎÀ…   À…À…  À…;À…C  À…\
À…d  À…|À…„  À…À…¦   À†ë=Àˆ/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   Àˆ,•åÀœÉ“½/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(new RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(new Paint()..color = Colors.red);
///   canvas.drawPaint(new Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(new RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(new Paint()..color = Colors.red);
///   canvas.drawPaint(new Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(new RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(new Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(new RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(new Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. ÀœÓÀœÚ  ÀœáÀœè   À{À  À1ÀA  ÀNÀX   À’€ëÀ—  À¢Àª  ÀÁ
ÀÉ  ÀßÀç  ÀÿÀŸ  ÀŸ ÀŸ0  ÀŸOÀŸY   ÀŸcÀ Â-/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   À è_À¢"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À¢K€ßÀ¢ğ€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À¢ú	À£  À£	À£   À£.DÀ¤;€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À¤A	À¤I  À¤M
À¤V   À¤v8À¤{  À¤‚	À¤Š  À¤	À¤•   À¤²€ˆÀ¥R/// Add a rotation to the current transform. The argument is in radians clockwise. À¥À¥   À¥>JÀ¦X/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À¦]	À¦e  À¦h	À¦p   À¦ŒFÀ§€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À§&À§3   À§Õ?À§Ú  À§åÀ§ò   À¨‚îÀ©ùÅ/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. Àª	Àª  Àª Àª  Àª1Àª7  ÀªÀª%Àª&ÀªDÀ«	€ÑÀ«  À«À«   À«6
À«>  À«SÀ«[  À«rÀ«z  À«’
À«—  À«¯À«µ   À«Ş‚XÀ­Š–/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À­”À­›  À­¢À­¨  À­µÀ®9OÀ®>  À®IÀ®V  À®\À®b   À®Œ‚1À°d/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À°	À°  À°À°!  À°.À°ÀEÀ°Å  À°Ï	À°Õ  À°ÚÀ°à   À±	JÀ±º€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. À±ÄÀ±Ë  À±ÑÀ±Ü   À²VDÀ²[  À²f	À²k  À²qÀ²v   À²ÄÀ³€â/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin. À³—	À³Ÿ  À³¢	À³ª  À³­À³´   À´e€ÚÀ´j  À´t	À´|  À´	À´˜  À´¬	À´´  À´È	À´Ğ  À´äÀ´ô  ÀµÀµ   ÀµC€şÀµİ€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀµçÀµî   À¶D[À¶I  À¶TÀ¶d  À¶qÀ¶{   À¶£YÀ·3€†/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style]. À·<	À·B  À·GÀ·N   À·ÿ€äÀ¸  À¸À¸  À¸,
À¸4  À¸IÀ¸Q  À¸hÀ¸p  À¸ˆÀ¸˜  À¸¶À¸À   À¸ç@À¹€/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style]. À¹‰À¹  À¹–À¹   Àº*€’Àº/  Àº:ÀºG  Àº_Àºo  ÀºÀº˜   ÀºÀ‚À»Ö/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. À»áÀ»è  À»îÀ»õ  À»ûÀ¼   À¼Ç€¼À¼Ì  À¼ØÀ¼å  À¼şÀ½  À½$À½4  À½TÀ½^   À½‡À¾M€º/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style]. À¾V	À¾\  À¾aÀ¾h   À¿€äÀ¿  À¿(À¿0  À¿F
À¿N  À¿cÀ¿k  À¿‚À¿Š  À¿¢À¿²  À¿ĞÀ¿Ú   ÀÀÆÀÁ/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style]. ÀÁ ÀÁ(  ÀÁ*ÀÁ2  ÀÁ9ÀÁ@   ÀÁÊ€ÌÀÁÏ  ÀÁÛÀÁã  ÀÁøÀÂ   ÀÂÀÂ  ÀÂ7ÀÂG  ÀÂgÀÂq   ÀÂšƒ¼ÀÅ7‚/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. ÀÅ?	ÀÅE  ÀÅJÀÅR  ÀÅ]ÀÅe  ÀÅpÀÅv  ÀÅ€ÀÅ‡   ÀÆYCÀÆ^  	ÀÆgÀÆo  ÀÆ„
ÀÆŒ  ÀÆ ÀÆ¨  ÀÆ¾ÀÆÆ  ÀÆİÀÆå  ÀÇ ÀÇ  ÀÇ#ÀÇ)  ÀÇCÀÇS  ÀÇpÀÇz   ÀÇ ±ÀÈ€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀÈ§	ÀÈ­  ÀÈ²ÀÈ¹   ÀÉT€†ÀÉY  ÀÉc	ÀÉi  ÀÉÀÉ  ÀÉ­ÀÉ·   ÀÉŞÏÀÊˆ€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀÊ’ÀÊ™  ÀÊŸÀÊ§  ÀÊ®ÀÊµ   ÀË°€ïÀËµ  ÀËÀÀËÈ  ÀËàÀËè  ÀËüÀÌ  ÀÌÀÌ(  ÀÌGÀÌQ  ÀÌmÀÌr   ÀÌ£„ÀÎ_¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. ÀÎmÀÎt  ÀÎzÀÎ€  ÀÎ„ÀÎŠ  ÀÎÀÎ•   ÀĞ½ÿÀĞÂ  ÀĞÑÀĞÙ  ÀĞõÀĞı  ÀÑÀÑ#  ÀÑ@ÀÑH  ÀÑgÀÑo  ÀÑÀÑ—  ÀÑµÀÑ½  ÀÑÚÀÑâ  ÀÒÀÒ	  ÀÒ)ÀÒ9  ÀÒ\ÀÒf  ÀÒ†ÀÒ‹   ÀÒÀ…ÀÕÒ‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀÕàÀÕç  ÀÕíÀÕó  ÀÕúÀÖ   ÀÖÀÖ   ÀØB‚ÀØG  ÀØVÀØ^  ÀØzÀØ‚  ÀØ£ÀØ«  ÀØËÀØÓ  ÀØõÀØı  ÀÙ ÀÙ(  ÀÙFÀÙN  ÀÙkÀÙs  ÀÙ’ÀÙš  ÀÙºÀÙÊ  ÀÙíÀÙ÷  ÀÚÀÚ   ÀÚQ€èÀÚ¶[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. ÀÚÂÀÚË   ÀÛ<?ÀÛA  ÀÛNÀÛW   ÀÛ„ÃÀß–ƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [new ParagraphBuilder] constructor. For more details see
/// [TextAlign] and the discussion at [new ParagraphStyle].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. Àß¤Àß¯  Àß¹ÀßÁ   ÀàF‚Àáb/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. ÀámÀáx  Àá‚Àá  Àá—Àá   Àâ\‚ÆÀãÑ]/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. ÀãßÀãê  ÀãôÀä  ÀäÀä   Àå&€¹Àå+  Àå7ÀåG  ÀågÀåq  ÀåÀå“  Àå°Àå½   Àåã…ÀéÜƒË/// Draws the set of [Vertices] onto the canvas.
///
/// The [blendMode] parameter is used to control how the colors in
/// the [vertices] are combined with the colors in the [paint].
/// If there are no colors specified in [vertices] then the [blendMode] has
/// no effect. If there are colors in the [vertices],
/// then the color taken from the [Shader] or [Color] in the [paint] is
/// blended with the colors specified in the [vertices] using
/// the [blendMode] parameter.
/// For purposes of this blending,
/// the colors from the [paint] are considered the source and the colors from
/// the [vertices] are considered the destination.
///
/// All parameters must not be null.
///
/// See also:
///   * [new Vertices], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. ÀééÀéó  ÀéüÀê  ÀêÀê   Àêô€ÂÀêù  ÀëÀë  Àë/Àë4  ÀëSÀëc  Àë…Àë   Àëºœ´À {“½/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.centerX,
///           translateY: sprite.centerY,
///         ),
///     ], <Rect>[
///       for (Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.centerX,
///           translateY: sprite.centerY,
///         ),
///     ], <Rect>[
///       for (Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À …À Œ  À £À ¶  À ÒÀ Ş  À õÀ  ÀÀ'  ÀBÀI  ÀcÀj   Àr”À!q—ß/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       final double rectX = sprite.spriteIndex * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.centerX - 5.0;
///       transformList[i * 4 + 3] = sprite.centerY - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       final double rectX = sprite.spriteIndex * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.centerX,
///         translateY: sprite.centerY,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. À!~À!…  À!ŸÀ!¬  À!ÎÀ!Û  À!õÀ"  À"À"(  À"FÀ"M  À"jÀ"q   À&
xÀ&  	À&À&*  À&IÀ&S  À&oÀ&t  À&™À&¡  À&¹À&Æ  À&æÀ&ó  À'À'  À'0À'5  À'QÀ'_   À'†‚À(o€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. À(z	À(€  À(…À(Œ  À(’À(š  À(¤À(ª   À)€§À)“  À)Ÿ	À)¥  À)½	À)Â  À)ÛÀ)ã  À* À*    À*9‰üÀ+¨N/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method. À+Õ€ÊÀ,šÀ,›À,œ€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder]. À,wÀ,xÀ,~À,À,À1jÀ1o À1{À1„™À2=€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À3!À3û€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   À,£ƒ;À.^œ/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// Although the image is returned synchronously, the picture is actually
/// rasterized the first time the image is drawn and then cached. À.f	À.k  À.q
À.v   À/â^À/ê  À/ó	À/ø  À/ş
À0  À0
À0   À0D€ôÀ0¼n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À1<)À1A    À+ˆÀ+‰À+À+ À+À47†fÀ5€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. À5G€å À6À6€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor. À5ëÀ5ìÀ5òÀ6À5óÀ:‹À:“  À6l¬À7ùu/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   À6/9À64    À8‚À99
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.   À::MÀ:?  À:MÀ:V    À:Ÿœ–À:úT/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. À;‚Ì À<À<–p/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.À<(À<£  À<ËÀ<Ñ  À<êÀ<ğ  !À<ªÀ<°À<µÀ<ÄÀ<¶À<ÙÀ<ßÀ<àÀ<üÀ=À=À=À=;À=À=À=À=À=EÀ=KÀ=ZÀ=zÀ=SÀ=LÀ=VÀ=\À=„À=ŠÀ=œÀ=ÏÀ=–À=‹À=™À=	À=Õ,À=æ À=÷À>)&À>: À>MÀ>S'À>d À>vÀ>tÀ>yÀ>~#À> À>À>›À> À>¥#À>¶ À>ÄÀ>ÂÀ>ÇÀ>Ì&À>İ À>îÀ>ìÀ>ñÀ>÷€¼À?®€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. À?¸4À@æ/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. À@ñiÀAPO/// The standard deviation of the Gaussian to convolve with the shadow's shape. ÀBß€®ÀC_n/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   ÀPşFÀQ   ÀPşÀPÿÀA_|ÀB~h/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// ÀB“ÀB›   ÀC‘‚‹ÀE¡õ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   ÀF €õÀF‡[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. ÀFÀF•   ÀG…ğÀK%ƒÖ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from a
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} ÀK*	ÀK3  ÀK5	ÀK>  ÀK@ÀKH   ÀM‚şÀMÒ€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} ÀMÛÀMê  ÀMìÀMû  ÀMıÀN   ÀP€ëÀP)  ÀP,ÀP4  ÀPÀPÀR„áÀR  ÀR!ÀR0   ÀVçLÀVú   ÀVçÀVè ÀW7‡&ÀWí€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. ÀX"ÀX1ÀX2ÀX3 ÀX4ÀX:   ÀYÿDÀZ=1/// The length, in bytes, of the underlying data. ÀZHÀZM ÀZ^ÀZhÀZñy/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀXE`ÀXÇ^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. ÀXÕÀXà   ÀY¨SÀY­  ÀY³ÀY¾  ÀYÃÀYÔ   À[ƒ‚£À]‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   À^*1À^/     À^_À_€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À_PÀ__À_`À_a   Àa0ƒ<ÀbÿÀc Àcr/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data in the encoding described by
/// `format`.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.Àc	Àc  Àc'Àc5  Àc?ÀcM  ÀcXÀc^  Àck Àc   ÀeÀe  ÀeçÀeì  ÀfÆÀfË  ÀeP€“ÀeÃd/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   Àf+€—ÀfŸe/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   Àg€¯Àg–h/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   	À_hUÀ_ÒH/// Creates an image descriptor from encoded data in a supported format. À_ÚÀ_ë   À`ÀlÀ`È  À`ÕÀ`æ  À`íÀ`ş   Àdo€œÀdt  Àd}Àd  ÀdœÀd­  Àd´	Àd¹  Àd¿
ÀdÄ  ÀdËÀdĞ  ÀdÙÀdŞ   Àe/Àe"    Àe÷1Àeû    Àfİ?Àfá    ÀgÒ€£ÀhJn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   Àhy„îÀj‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. Àj.Àj4  Àj@ÀjF   ÀmjtÀmo  ÀmÀmˆ  Àm‘Àm–  Àm¢Àm§     ³éÀ Nc¿‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ¿»€îÀ @¤€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) À @®HÀ Aó4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) À AûMÀ CE9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À CMìÀ E2Ğ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À E>­À Fä‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À Fğ‚šÀ I…‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À I‚„À L‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À L‚˜À Nª‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À Nµ‚À Q=‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À QH‚gÀ S¨‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À S´‚]À V
‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À V;À WN+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À WVÀÀ Y©/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À YƒVÀ \iƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À \¿…!À aÚ„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À aşƒŞÀ eÕƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À eá7À g"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À g:À hP$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À h\{À iÍb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À iÜ‘À kdy/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À krƒâÀ oKƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À oYsÀ pÃU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À pÑÅÀ rŒ¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À r›ÔÀ tf²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À tt‚ÙÀ wE‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À wo‚÷À zc‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À zk‚dÀ |Å‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À |Ô‚ãÀ ²‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À ¼‚À ‚?‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ‚NŒ{À ‡È…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À ˆY€ÙÀ ‰.€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ‰7€²À ‰æ€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ‰î‚À Œv‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Œ‚EÀ Â‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À Ë†ÇÀ ¿€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À Í…À ‘Nr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À ‘WËÀ “µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À “'‚hÀ •‰‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À •”ˆÀ —?g/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À —N‚YÀ ™¢‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À ™¬ÌÀ ›s®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ›}‚À ÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À ™‚ßÀ 2T/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À ¤€·À ŸW€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À Ÿ`À  o/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À  {Œ‡À  ¯./// Different ways to clip a widget's content.  À  ¸‚8À ¢ì‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¢õ‚_À ¥L‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ¥Yƒ.À ¨~ƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¨Œ„sÀ ¬é„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À óf†;À ôòY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À õ€‚À õt/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À õ€À öx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À ö €»À öÎ€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À öà‚¾À ù›‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À ù£ÔÀ ùç>/// The format of pixel data given to [decodeImageFromPixels].  À ù÷€¼À ú«€­/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. À ú¸€¼À ûl€­/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha.    ÀI’ƒ•ÀJ/€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  ÀJ@¯ÀKè—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> ÀKô0ÀM/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    ÀM)ˆLÀMİ€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  ÀMï£ÀOˆ„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. ÀO–‡ÀQk/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation ÀQ!$ÀR@/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. ÀRI‚ÀSÈn/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation ÀSÏ£ÀUa}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    ÀÅbƒ{ÀÅØ4/// Styles to use for blurs in [MaskFilter] objects.  ÀÆ€–ÀÆ¯€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. ÀÆº€ÍÀÇ‚€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. ÀÇŒ€æÀÈm€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. ÀÈwcÀÈÕY/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    À†“ÀY†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  Àf‚£À‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) Àƒ5À;ƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) ÀHƒ|À¾ƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) ÀÉ‚½À!‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    Àd4÷Àdøw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀeQÀeOE/// Draw each sequence of three points as the vertices of a triangle. Àe][Àe«K/// Draw each sliding window of three points as the vertices of a triangle. Àe½kÀf]/// Draw the first point and each sliding window of two points as the vertices of a triangle.    Àx
„ÀxÆr/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints].  ÀxÔ·Àz…/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). Àz€éÀ{t€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). À{~€šÀ|€Š/// Draw the entire sequence of point as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À|À|›x/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  À|¦BÀ|Ş5/// Subtract the new region from the existing region. À|íBÀ}&6/// Intersect the new region from the existing region.      ƒå‚…Vj/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate} …c	…i   …õ€©…ú  ††   † €Æ†¥  †´†¼   ‡h‡m  ‡}‡Š   ˆ~€Äˆƒ  ˆ’ˆš   ‰Dm‰J  ‰V‰]  ‰_‰g   À3,ˆÚÀ9w†</// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. À9À9›  À9¤À9ª  À9¸À9¾  À9ÍÀ9Ó  À9ãÀ<©À=>0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. À=RÀ=]  À=bÀ=x   À=³À=À  À=ÚÀ=å  À>À>'   À>ËŠÅÀD…D/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data in the encoding described by
/// `format`.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	ÀD.ÀD9  ÀDB	ÀDG  ÀDO
ÀDT  ÀD]ÀDj  ÀDsÀD‰  ÀD–ÀDœ  ÀD§ÀD­  ÀD»ÀDÁ  ÀDĞÀDÖ  ÀDæÀ!‹€åÀ!•  À!¦À!³   À"rµÀ"~  À"À"   À$)$À$5  À$FÀ$N  À$UÀ$]   Ào† Àry‚f/// Converts a method that receives a value-returning callback to a method that
/// returns a Future.
///
/// Return a [String] to cause an [Exception] to be synchronously thrown with
/// that string as a message.
///
/// If the callback is called with null, the future completes with an error.
///
/// Example usage:
///
/// ```dart
/// typedef IntCallback = void Function(int result);
///
/// String _doSomethingAndCallback(IntCallback callback) {
///   Timer(new Duration(seconds: 1), () { callback(1); });
/// }
///
/// Future<int> doSomething() {
///   return _futurize(_doSomethingAndCallback);
/// }
/// ```ÀrƒÀrƒÀr†Àr–    À mÀ Ç1/// Callback signature for [decodeImageFromList].  À ìÀ ó   ÀmâdÀn4/// Generic callback signature, used by [_futurize].Àn)Àn) Àn<Àn?   ÀnH€ÕÀnã€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀnïÀnï ÀoÀo     •û <€†€¤€¥€¦€¶€Ç€È_¯‚ ‚P‚‚ïƒ-ƒ0ƒ~ƒ¤ƒ¥ƒå„
„[„¡„í…=…P…Q…p…£…ã…ò…ô…õ††L†††Ÿ† †Å†ü‡V‡e‡g‡h‡”‡Íˆˆlˆ{ˆ}ˆ~ˆ£ˆÚ‰2‰A‰C‰D‰p‰°‰²‰³‰ç‰ëŠ;Š‹ŠÚ‹‹‹6‹:‹F‹m‹©‹àŒŒŒ#ŒtŒÃ?COœäìğşU›©åëDj‘¶¼ZˆÔ‘!‘F‘b‘™‘š‘Ú‘à’-’=’b’‰’¯’µ’ø’ş“I“V“‹“­“Ï“ñ”” ”u”{” ”Ç”í•:•j•p•³•¹––?–u–«–á—#—$—R—X—€—†—®—Ô—û˜ ˜3˜4˜m˜s˜Â˜ä™™™G™M™™À™æ™çššKšLš…š³š´šì›››c›™›Ÿ›×›òœ"œ&œ'œpœ¸œ¾œöJ{€Ğı;T†Š‹ÔŸ
ŸŸHŸcŸ“Ÿ—Ÿ˜Ÿé   T n Ÿ £ ¤ â¡¡=¡]¡¡¢¡£¡î¡ô¢H¢f¢l¢ª¢È££C£€£¼£í£ñ£ò¤!¤'¤o¤²¤¸¥¥O¥¥Ô¥Ú¦'¦q¦¼§§V§¦§ó¨D¨q¨w¨Æ¨æ©©2©G©^©s©‚©ª©²©¿©Ö©øªª&ªjªªªî«0«;«C«I«M«N«‘«×«İ¬)¬p¬»­
­U­•­½­ü®®®B®h®Ÿ®¼®Ê¯¯Z¯¢¯«¯È¯ú°(°H°e°w°Â±±^±g±m±q±r±¿±Å±ğ²#²@²t²x²y²…²¨²È²Û³³³3³T³X³Y³e³‹³Œ³˜³æ³è³é´´ ´m´·´Ö´Úµ+µxµÇ¶¶e¶°¶ô¶ø·H·“·ä¸0¸~¸Ë¹¹]¹¬¹òººº_º¬ºö»H»•»æ¼'¼+¼R¼V¼¤¼å½6½ƒ½Ô¾#¾r¾¾‘¾Ÿ¾£¾î¾ÿ¿¿_¿r¿¸¿¹¿ıÀ @À @?À @EÀ @¢À @«À @¬À @ëÀ @ñÀ A@À AOÀ AUÀ AÀ A–À AñÀ AøÀ AùÀ B8À B>À B‰À BšÀ B À BâÀ BèÀ CCÀ CJÀ CKÀ CˆÀ CÀ CÜÀ D-À DJÀ DPÀ DÀ DËÀ DÑÀ E0À E;À E<À EzÀ E€À E©À E¯À EıÀ FÀ FbÀ FhÀ F·À FâÀ FíÀ FîÀ G6À GƒÀ GĞÀ GŞÀ GäÀ H#À H)À HvÀ H¾À HÎÀ HÔÀ I À I&À IƒÀ IŒÀ IÀ IÚÀ J(À JrÀ JxÀ J²À J¸À KÀ KWÀ K]À K©À K¯À LÀ LÀ LÀ LeÀ L¸À MÀ MÀ MMÀ MSÀ M À MñÀ M÷À NDÀ NJÀ N¨À N²À N³À OÀ OUÀ OŸÀ O¥À OàÀ OæÀ P8À P„À PŠÀ P×À PİÀ Q;À QEÀ QFÀ Q•À QµÀ Q»À R	À RÀ R_À R«À RßÀ RåÀ S0À SAÀ SGÀ S¦À S±À S²À TÀ TÀ T"À TpÀ TvÀ TÆÀ UÀ UAÀ UGÀ U’À U£À U©À VÀ VÀ VÀ VdÀ V˜À VÀ VëÀ VñÀ WLÀ WSÀ WTÀ W“À W™À WèÀ X4À XZÀ X`À X®À X´À YÀ YÀ YÀ YcÀ YiÀ Y¸À ZÀ ZÀ Z^À Z‡À ZÀ ZŞÀ ZäÀ [DÀ [JÀ [ZÀ [`À [¢À [êÀ \À \PÀ \gÀ \sÀ \tÀ \¼À \½À ]À ].À ]4À ]€À ]ÍÀ ]üÀ ^À ^SÀ ^ŸÀ ^ÅÀ ^ËÀ _À _jÀ _»À _ÁÀ `À `2À `8À `–À `œÀ `¬À `²À aÀ aÀ a[À awÀ aÁÀ aØÀ aûÀ aüÀ bEÀ btÀ bzÀ bËÀ cÀ cjÀ c‰À cÀ cÛÀ d(À dWÀ d]À d¼À dÂÀ dÒÀ dØÀ eÀ eXÀ e¨À eÓÀ eŞÀ eßÀ f-À fLÀ fRÀ f›À f¬À f²À gÀ gÀ gÀ gjÀ g‰À gÀ gØÀ géÀ gïÀ hNÀ hYÀ hZÀ h•À h›À hçÀ i4À icÀ iiÀ iËÀ iÙÀ iÚÀ j-À j3À jÀ jÌÀ jûÀ kÀ kbÀ koÀ kpÀ k¹À kãÀ kéÀ l9À l‚À lĞÀ lıÀ mÀ mOÀ mœÀ mËÀ mÑÀ n2À n8À nHÀ nNÀ n‡À nÎÀ oÀ oIÀ oVÀ oWÀ o¥À o½À oÃÀ pÀ pÀ plÀ prÀ p‚À pˆÀ pÁÀ pÎÀ pÏÀ qÀ qÀ qmÀ q„À qŠÀ qÓÀ qäÀ qêÀ r"À r(À rŠÀ r˜À r™À råÀ róÀ rùÀ sHÀ s_À seÀ s®À s¿À sÅÀ sıÀ tÀ tdÀ tqÀ trÀ tÀÀ tÙÀ tßÀ u.À u}À uƒÀ uÏÀ vÀ vdÀ vjÀ v¹À vİÀ vãÀ wCÀ wlÀ wmÀ w¾À w×À wİÀ x&À x,À xuÀ xÅÀ xëÀ xñÀ yLÀ yRÀ ybÀ yhÀ y¸À yáÀ z0À zaÀ zhÀ ziÀ zºÀ zÓÀ zÙÀ {"À {rÀ {ŸÀ {¥À | À |À |À |À |^À |­À |ÃÀ |ÑÀ |ÒÀ }#À }<À }BÀ }‹À }‘À }ÚÀ ~*À ~_À ~eÀ ~ÂÀ ~ÈÀ ~ØÀ ~ŞÀ À bÀ °À ¹À ºÀ €À €$À €*À €sÀ €ÃÀ €ğÀ €öÀ XÀ ^À nÀ tÀ ÃÀ ÙÀ ‚$À ‚=À ‚KÀ ‚MÀ ‚NÀ ‚¦À ‚áÀ ‚åÀ ƒBÀ ƒ‰À ƒÀ ƒâÀ „6À „ŒÀ „àÀ „äÀ …2À …mÀ …qÀ …ÊÀ …ÎÀ †À †cÀ †‚À ††À †”À †˜À †ãÀ ‡À ‡2À ‡OÀ ‡jÀ ‡‰À ‡¨À ‡ÃÀ ‡ØÀ ˆ.À ˆVÀ ˆWÀ ˆ›À ˆ¡À ˆçÀ ‰,À ‰4À ‰5À ‰mÀ ‰sÀ ‰µÀ ‰äÀ ‰ëÀ ‰ìÀ Š6À Š^À ŠdÀ Š¯À ŠüÀ ‹EÀ ‹À ‹–À ‹ÆÀ ‹ÖÀ ‹ÜÀ Œ+À Œ_À ŒtÀ Œ~À ŒÀ ŒÏÀ ŒÜÀ ŒâÀ 0À mÀ sÀ šÀ  À òÀ BÀ À “À ÀÀ ÈÀ ÊÀ ËÀ ïÀ óÀ À À :À }À ºÀ ËÀ À À bÀ ÆÀ ÌÀ ‘À ‘LÀ ‘TÀ ‘UÀ ‘À ‘–À ‘àÀ ’0À ’ À ’¦À ’öÀ “À “$À “%À “hÀ “­À “ÒÀ “ØÀ ”'À ”˜À ”À ”îÀ •À •À •gÀ •‡À •‘À •“À •”À •¾À •ÂÀ –À –SÀ –WÀ –eÀ –iÀ –µÀ –ÁÀ –üÀ —:À —LÀ —‚À —ˆÀ —ñÀ —÷À ˜?À ˜À ˜›À ˜¡À ˜±À ˜·À ™À ™À ™gÀ ™ À ™©À ™ªÀ ™ßÀ ™åÀ šLÀ šRÀ ššÀ šêÀ šöÀ šüÀ ›À ›À ›`À ›qÀ ›zÀ ›{À ›ÉÀ ›ûÀ œÀ œhÀ œnÀ œ¶À À À À (À .À |À À –À ˜À ™À ÓÀ ×À îÀ -À BÀ “À ¡À ¢À èÀ Ÿ.À ŸUÀ Ÿ]À Ÿ^À Ÿ¢À ŸèÀ  /À  mÀ  wÀ  yÀ  zÀ  {À  ªÀ  ¶À  ÌÀ  ÒÀ ¡À ¡nÀ ¡tÀ ¡ÀÀ ¡ÖÀ ¢#À ¢|À ¢ÑÀ ¢êÀ ¢òÀ ¢óÀ £À £%À £~À £¯À £µÀ £õÀ £ûÀ ¤SÀ ¤®À ¤´À ¤ÄÀ ¤ÊÀ ¥&À ¥JÀ ¥VÀ ¥WÀ ¥vÀ ¥|À ¥ÈÀ ¥ÎÀ ¦!À ¦'À ¦nÀ ¦tÀ ¦ÉÀ ¦èÀ §?À §EÀ §UÀ §[À §£À §îÀ ¨À ¨|À ¨‰À ¨ŠÀ ¨ÖÀ ¨ÜÀ ©/À ©À ©ªÀ ©°À ªÀ ªOÀ ª¡À ªóÀ ªùÀ «IÀ «™À «çÀ ¬7À ¬}À ¬ƒÀ ¬“À ¬™À ¬çÀ ­À ­À ­À ­FÀ ­JÀ ­À ­¯À ­½À ­ìÀ ­ñÀ ®<À ®‡À ®ÖÀ ¯$À ¯sÀ ¯xÀ ¯ÈÀ °À °*À °/À °wÀ °xÀ °¬À °­À °ØÀ °ıÀ ±&À ±KÀ ±vÀ ±ŸÀ ±ÉÀ ±ùÀ ²&À ²PÀ ²„À ²´À ²àÀ ³À ³À ³JÀ ³€À ³¾À ³ôÀ ´6À ´tÀ ´´À µ À µFÀ µ†À µØÀ ¶"À ¶dÀ ¶œÀ ¶İÀ ·À ·À ·KÀ ·fÀ ·gÀ ·•À ·éÀ ·íÀ ·îÀ ¸À ¸?À ¸jÀ ¸¾À ¸¿À ¹À ¹À ¹)À ¹DÀ ¹ZÀ ¹`À ¹dÀ ¹eÀ ¹«À ¹¹À ¹¿À ¹×À ¹ğÀ º7À º;À º[À º«À ºÕÀ ºüÀ »@À »DÀ »EÀ »}À »­À »®À »çÀ »íÀ ¼À ¼À ¼#À ¼)À ¼oÀ ¼ À ¼èÀ ¼îÀ ½6À ½KÀ ½_À ½¨À ½ÔÀ ½ØÀ ½óÀ ¾À ¾DÀ ¾‚À ¾†À ¾‡À ¾¿À ¿ À ¿À ¿MÀ ¿SÀ ¿•À ¿æÀ À7À ÀXÀ À^À À«À ÀÌÀ ÀÒÀ ÀùÀ ÀÿÀ ÁÀ ÁÀ ÁdÀ Á˜À ÁâÀ ÁøÀ ÂÀ ÂaÀ ÂœÀ Â À ÂÃÀ ÂŞÀ ÃÀ ÃZÀ Ã^À Ã_À Ã£À Ã©À ÃÑÀ ÃíÀ Ä?À ÄCÀ ÄfÀ ÄÀ Ä¦À ÄäÀ ÄèÀ ÄéÀ Å#À ÅrÀ Å¯À ÅµÀ ÅòÀ ÆÀ ÆQÀ ÆUÀ ÆwÀ Æ’À Æ´À ÆúÀ ÆşÀ ÆÿÀ Ç@À ÇpÀ ÇvÀ Ç¨À ÇÄÀ ÈÀ ÈÀ È=À ÈXÀ È}À È¿À ÈÃÀ ÈÄÀ ÉÀ ÉÀ É\À É§À É­À ÉçÀ ÉíÀ ÊÀ ÊÀ ÊzÀ Ê€À ÊçÀ ÊíÀ ËTÀ ËZÀ Ë¦À Ë÷À ÌÀ Ì	À ÌÀ ÌÀ ÌnÀ ÌšÀ ÌãÀ Í"À Í@À Í”À Í˜À Í½À ÍØÀ ÍıÀ Î@À ÎDÀ ÎEÀ Î}À Î´À ÎµÀ Ï À ÏNÀ Ï™À ÏæÀ Ğ4À Ğ:À ĞÀ Ğ…À ĞÓÀ Ğ÷À ĞıÀ ÑfÀ ÑlÀ ÑÕÀ ÑÛÀ ÒDÀ ÒJÀ Ò–À ÒçÀ ÒóÀ ÒùÀ Ó	À ÓÀ ÓYÀ ÓtÀ Ó½À ÓİÀ Ô&À Ô*À ÔQÀ ÔlÀ ÔªÀ ÔõÀ ÔùÀ ÔúÀ ÕJÀ ÕˆÀ ÕÀ Õ²À ÕÑÀ ÖÀ Ö6À ÖKÀ ÖlÀ ÖŒÀ ÖçÀ ×.À ×9À ×?À ×PÀ ×TÀ ×zÀ ×“À ×åÀ Ø-À ØuÀ Ø‚À ØÏÀ ÙÀ ÙSÀ Ù¬À ÙıÀ ÚÀ ÚÀ ÚÀ ÚZÀ Ú®À ÚúÀ Û À Û(À ÛuÀ Û™À ÛóÀ Û÷À Ü"À Ü=À ÜbÀ Ü¨À Ü¬À Ü­À ÜçÀ ÜíÀ İ#À İ)À İ9À İ?À İ{À İ³À İåÀ Ş-À ŞDÀ ŞtÀ ŞxÀ Ş–À ŞÎÀ ŞÒÀ ŞÓÀ ßÀ ß,À ß2À ßWÀ ß]À ß®À ßÏÀ à&À àHÀ àLÀ àMÀ àuÀ à»À àÛÀ àùÀ á'À á/À á<À á‚À áˆÀ áŒÀ áÀ áÈÀ áÎÀ âÀ â/À â5À âCÀ âaÀ âgÀ â}À âƒÀ â°À âÊÀ âÛÀ âòÀ ã@À ãKÀ ãSÀ ã]À ãcÀ ãsÀ ãyÀ ã´À ãÕÀ ä,À äNÀ äRÀ äSÀ ä{À ä”À ä²À äàÀ äèÀ äõÀ å6À åŒÀ å·À åûÀ æÀ æ	À æÀ æÀ æMÀ æSÀ æŸÀ æéÀ çÀ ç4À ç{À çÀ ç À çêÀ çîÀ çïÀ èÀ èFÀ èJÀ èfÀ è«À è¯À è°À èèÀ èîÀ é:À é€À é³À é¹À éÿÀ ê À ê&À êsÀ ê¿À êâÀ êèÀ ë/À ë}À ë¤À ë¥À ë±À ëÇÀ ìÀ ì4À ì:À ìjÀ ì…À ì¡À ìÊÀ ìèÀ íÀ íBÀ íMÀ ípÀ í—À í¼À íèÀ î#À îxÀ î‡À î­À îµÀ îÍÀ îÓÀ îòÀ ï#À ï;À ïAÀ ïqÀ ï™À ï±À ï·À ïèÀ ğÀ ğ,À ğ2À ğQÀ ğÀ ğ¦À ğ¬À ğÊÀ ñÀ ñÀ ñ#À ñRÀ ñ“À ñ«À ñ±À ñËÀ ñşÀ òÀ òÀ ò;À òxÀ òÀ ò–À ò¬À òåÀ òöÀ ó*À óAÀ ó_À ócÀ óeÀ ófÀ ó¨À óÀÀ ôÀ ô[À ô£À ôíÀ õÀ õÀ õ!À õÀ õŠÀ õ‹À õ«À õ±À ö
À öÀ öÀ ö;À öAÀ ö‘À öÌÀ öİÀ öŞÀ öğÀ ööÀ ÷FÀ ÷”À ÷àÀ ø-À øvÀ ø|À øÍÀ øÙÀ øßÀ øïÀ øõÀ ùTÀ ù™À ù À ù¢À ù£À ùâÀ ùõÀ úCÀ ú“À ú©À úµÀ ú¶À ûÀ ûTÀ ûjÀ ûvÀ ûxÀ ûyÀ û¯À û³À ûóÀ û÷À üEÀ ü]À üaÀ ü°À üÿÀ ıFÀ ıÀ ıÜÀ ıêÀ ıîÀ ş:À ş‰À şĞÀ şÔÀ şâÀ şæÀ ÿTÀ ÿ£À ÿÉÀ À &À ?À OÀ wÀ ŠÀ ”À ³À ·À ¸À ÙÀ õÀÀÀ(À)ÀmÀÀ¬ÀÅÀÉÀÊÀÀÀLÀfÀjÀkÀ…ÀÒÀÀ	ÀZÀuÀ{ÀÆÀÀ`À€À“ÀÀÀìÀÀ9ÀNÀqÀ‰ÀÀ“À”ÀØÀŞÀ,ÀBÀ]ÀqÀÀÀ°ÀºÀ(À,À-ÀbÀhÀ´ÀÄÀÊÀÀ0À€ÀÏÀ	À	eÀ	ºÀ	çÀ
À
À
À
kÀ
À
“À
ÓÀ	À'À7À‹ÀÀ¨À»À¿ÀÀÀñÀ÷ÀFÀ•ÀæÀ2À~ÀÌÀÀ6À<ÀŠÀ³À¹ÀÀRÀhÀnÀ¤ÀªÀ¸ÀÓÀÙÀÀPÀoÀ¹ÀÊÀÜÀüÀLÀšÀÀÀöÀÀ"À*À0ÀRÀ†ÀÑÀüÀ?ÀƒÀÀÀÙÀßÀÀKÀQÀnÀˆÀÀ°ÀÎÀéÀñÀ÷ÀÀ6À<ÀWÀ]À€À¹ÀÃÀÉÀôÀüÀÀÀQÀŸÀÃÀÕÀêÀÀ-À~ÀÌÀÀÀÀ<ÀXÀ\À]À©ÀïÀõÀBÀŒÀÜÀ+ÀuÀÂÀûÀüÀÀ2À4À5ÀOÀÀÈÀãÀèÀ6ÀXÀtÀ‚ÀƒÀ©ÀªÀÒÀÓÀ(À^ÀœÀÌÀÖÀŞÀâÀãÀÀ|À}À—ÀªÀÂÀÎÀæÀ3ÀKÀ•ÀÍÀÔÀêÀúÀşÀÿÀ )À *À MÀ NÀ ZÀ ŠÀ ŒÀ À ¿À ûÀ üÀ!0À!4À!pÀ!ŠÀ!À!ØÀ"!À"oÀ"µÀ# À#)À#-À#fÀ#jÀ#vÀ#‚À#¹À#÷À$À$bÀ$­À$ÊÀ%À%5À%VÀ%\À%dÀ%hÀ%~À%‚À%À%›À%ÒÀ&À&PÀ&À&ÛÀ&õÀ'DÀ'ŒÀ'­À'³À'»À'ÍÀ(À(3À(9À(wÀ(“À(ÑÀ(ÒÀ)À)À)TÀ)oÀ)pÀ)qÀ)šÀ) À)èÀ)îÀ*:À*OÀ*QÀ*RÀ*rÀ*vÀ*¾À*ØÀ*ÜÀ+À+1À+KÀ+zÀ+À+ÈÀ+ãÀ+èÀ,!À,?À,[À,hÀ,iÀ,ƒÀ,©À,äÀ-À-À-5À-dÀ-jÀ-À-ÃÀ.À.HÀ.IÀ.qÀ.wÀ.»À.ÁÀ/À/À/YÀ/‰À/´À/üÀ0PÀ0kÀ0àÀ0ïÀ1À18À1zÀ1†À1À1–À1¯À1ÍÀ1ÓÀ1ğÀ1ôÀ1õÀ21À2ŒÀ2À2İÀ3 À3)À3+À3,À3OÀ3SÀ3¢À3òÀ4@À4cÀ4gÀ4¹À5À5@À5DÀ5À5ÙÀ6)À6xÀ6ÄÀ7À7dÀ7¬À7èÀ7ìÀ86À8€À8ĞÀ9À9À9]À9iÀ9À9¢À9¶À9ËÀ9éÀ9ôÀ:@À:ŒÀ:¥À:æÀ;À;À;VÀ;~À;„À;ˆÀ;œÀ;ÂÀ;àÀ< À<À<À<À<QÀ<UÀ<¤À<òÀ=9À=ƒÀ=°À=²À=³À=êÀ>8À>qÀ>«À>ÈÀ>ÊÀ>ËÀ?À?À?VÀ?dÀ?hÀ?´À@À@DÀ@HÀ@“À@İÀA-ÀA|ÀAÈÀBÀBhÀB°ÀBìÀBğÀC:ÀC„ÀCÔÀDÀD,ÀD@ÀDMÀD[ÀDqÀD”ÀD¥ÀD¹ÀDÎÀDìÀDñÀEÀEBÀEFÀEdÀEšÀEÀEŸÀEÇÀEìÀF*ÀF:ÀFPÀFhÀF„ÀF¡ÀFªÀF«ÀFÈÀGÀG8ÀGBÀG‹ÀG·ÀGÁÀGÉÀGÊÀGÛÀGöÀHÀH@ÀHJÀHhÀH¬ÀHÇÀHãÀHîÀIÀI0ÀIPÀIQÀI}ÀI‰ÀIÀI‘ÀI’ÀIßÀIïÀIóÀJ*ÀJ>ÀJˆÀJÀJßÀK.ÀK}ÀK¨ÀK®ÀKæÀKñÀKòÀL4ÀL:ÀL‹ÀLÜÀLâÀMÀM&ÀM(ÀM)ÀMMÀMQÀM_ÀMcÀM²ÀMØÀMíÀN!ÀN'ÀNuÀNÀÀOÀOÀOÀOÀOlÀO†ÀO”ÀOãÀP	ÀPÀP]ÀP«ÀPÅÀPËÀPÛÀQÀQÀQjÀQpÀQ¾ÀR	ÀR>ÀRGÀR’ÀRËÀRÑÀSÀSsÀSyÀS‰ÀSÆÀSÍÀTÀTÀTUÀT ÀTáÀTçÀT÷ÀTıÀUFÀU_ÀUtÀUvÀUwÀUÈÀUâÀVÀVaÀV}ÀV™ÀV¬ÀV­ÀVıÀW ÀW&ÀWvÀW¿ÀXÀXYÀXsÀXyÀXÈÀYÀYNÀY}ÀYÀY€ÀY²ÀY¶ÀYûÀYÿÀZBÀZÀZ•ÀZ™ÀZßÀ[
À[À[MÀ[À[¸À[¼À\ À\9À\SÀ\À\©À\ÅÀ\âÀ]À]À]bÀ]§À]³À]´À]ÜÀ]âÀ^/À^~À^¡À^ÇÀ^æÀ^ıÀ_À_2À_3À_qÀ_wÀ_¼À` À`AÀ`BÀ`rÀ`¯À`°À`åÀaÀaÀafÀa°Àa±ÀaøÀbÀb=Àb>Àb…Àb·ÀcÀcÀcEÀc…Àc”ÀcúÀcûÀd>Àd…ÀdÊÀd×ÀeMÀeNÀe“ÀeÚÀeéÀfQÀfRÀf—ÀfŞÀg#Àg8Àg°Àg±Àg÷Àh;Àh€ÀhÇÀhìÀiHÀiIÀiÀiÓÀjÀj_Àj¥ÀjÍÀk9Àk:Àk}ÀkŸÀk¥ÀkèÀlÀlÀlYÀl™ÀlàÀm$ÀmkÀm¯ÀmİÀmãÀn(Àn^Àn°ÀnĞÀo/Ào3ÀowÀoÒÀoÓÀp"ÀpgÀpmÀp¼ÀqÀqIÀqpÀqvÀqÂÀrÀr]ÀrcÀr†Àr§ÀrÂÀrİÀrøÀrÿÀs#ÀsGÀs‹Às±ÀsµÀsøÀt;ÀtxÀtyÀtzÀtÉÀuÀuÀuHÀuNÀuÀuëÀv.ÀvxÀv~ÀvÈÀwÀwcÀwzÀwªÀwËÀwæÀxÀxÀx#ÀxLÀxpÀx¼ÀxôÀxøÀyCÀyÀy¹ÀyöÀy÷Àz>ÀzUÀzqÀz‘ÀzÍÀzÑÀ{.À{/À{qÀ{ŸÀ{¥À{÷À|EÀ|aÀ|À|½À|ÁÀ}À}À}gÀ}¤À}ãÀ~$À~jÀ~®À~òÀ~şÀ?À_À²À¶ÀûÀ€FÀ€GÀ€™À€§À€­À€üÀ!À'ÀnÀ£À¿ÀñÀõÀ‚BÀ‚CÀ‚…À‚ÈÀ‚ØÀ‚÷ÀƒÀƒ=ÀƒAÀƒ}Àƒ~ÀƒÄÀƒÊÀ„À„eÀ„À„ÓÀ…À…7À…RÀ…zÀ…¹À…ÆÀ…òÀ…øÀ…üÀ†DÀ†´À†µÀ†ûÀ‡:À‡wÀ‡}À‡ÊÀˆÀˆFÀˆÀˆĞÀˆôÀ‰À‰7À‰|À‰‰À‰¼À‰ÂÀ‰ÆÀŠÀŠ˜ÀŠ™ÀŠŞÀ‹À‹CÀ‹DÀ‹‰À‹ÍÀ‹èÀŒÀŒÀŒ]ÀŒªÀŒÉÀŒÏÀÀÀbÀ‚À¥ÀÏÀÓÀÀÀQÀ€ÀÀÂÀâÀ
ÀÀÀfÀgÀ§À×ÀÿÀ%ÀEÀdÀuÀyÀÇÀÈÀıÀ‘À‘SÀ‘ À‘ëÀ’*À’0À’À’ĞÀ“"À“oÀ“¹À”À”À”ZÀ”oÀ”šÀ”ØÀ”ÜÀ•À•À•]À•pÀ•vÀ•ÆÀ–À–NÀ–—À–²À–ÍÀ–ëÀ—À—1À—7À—®À—²À—öÀ—÷À˜FÀ˜wÀ˜}À˜ÉÀ™À™`À™¯À™ùÀš1Àš7Àš‚ÀšÏÀ›À›LÀ›RÀ›¢À›ïÀœ?Àœ‚ÀœÏÀÀkÀ»À
ÀÀ^À­ÀáÀçÀŸ8ÀŸƒÀŸ¾ÀŸëÀŸïÀŸñÀŸòÀ 4À 8À FÀ ¤À ´À åÀ ëÀ¡À¡=À¡]À¡{À¡|À¡ÁÀ¡ÇÀ¢À¢HÀ¢…À¢ÍÀ¢ÑÀ¢ÒÀ¢ñÀ¢÷À£JÀ£À£§À£¨À£ÕÀ£ÛÀ¤,À¤~À¤šÀ¤±À¤²À¤âÀ¤èÀ¥8À¥‡À¥£À¥©À¥÷À¦FÀ¦•À¦ãÀ¦ôÀ§9À§rÀ§tÀ§uÀ§½À§ÁÀ¨À¨^À¨¤À¨¨À¨îÀ¨òÀ©>À©À©«À©¯À©ùÀªIÀªjÀªªÀªÙÀ« À«!À«IÀ«JÀ«VÀ«ˆÀ«ŠÀ«‹À«ÚÀ«ôÀ¬/À¬yÀ¬zÀ¬•À¬²À¬³À¬¿À¬ÚÀ­À­.À­FÀ­©À®À®yÀ®‚À®ˆÀ®¢À®¦À®§À®³À®ÇÀ®îÀ¯À¯1À¯7À¯OÀ¯aÀ¯eÀ¯gÀ¯hÀ¯§À¯«À¯óÀ°>À°ŒÀ°°À°´À±À±QÀ±À±íÀ²;À²IÀ²\À²zÀ²šÀ²ØÀ³À³MÀ³NÀ³„À³›À³œÀ³ÁÀ³ÇÀ´À´[À´«À´ÊÀ´áÀ´âÀµÀµÀµcÀµªÀµøÀ¶GÀ¶€À¶†À¶ÔÀ·$À·sÀ·¬À·ÆÀ·ÇÀ·æÀ·çÀ·èÀ¸8À¸_À¸eÀ¸´À¹À¹À¹À¹TÀ¹ZÀ¹ À¹ÒÀºÀºÀºÀºaÀºgÀº©ÀºíÀ»;À»˜À»œÀ»À»©À¼À¼À¼À¼KÀ¼yÀ¼À¼¢À¼õÀ¼öÀ½À½À½²À½¶À½ùÀ½úÀ¾>À¾´À¾÷À¿2À¿NÀ¿aÀ¿nÀ¿„À¿ªÀ¿ÏÀ¿ØÀ¿ŞÀ¿âÀÀ>ÀÀ?ÀÀŸÀÁÀÁ5ÀÁ‰ÀÁšÀÁÀÂ,ÀÂ-ÀÂQÀÂÇÀÂëÀÂïÀÃ1ÀÃ2ÀÃ]ÀÃbÀÃ·ÀÃáÀÃùÀÄ%ÀÄ5ÀÄRÀÄXÀÄiÀÄmÀÄ«ÀÄ¬ÀÄøÀÄşÀÅ?ÀÅ_ÀÅaÀÅbÀÅ—ÀÅÓÀÅäÀÆÀÆÀÆjÀÆ­ÀÆ·ÀÆ¸ÀÇÀÇRÀÇ€ÀÇ‰ÀÇŠÀÇ×ÀÈ(ÀÈkÀÈtÀÈuÀÈÅÀÈÓÀÈÜÀÈŞÀÈßÀÉ,ÀÉ|ÀÉÀÉ’ÀÉãÀÉöÀÊAÀÊGÀÊ{ÀÊÀÊÒÀÊØÀË'ÀËuÀËÅÀËÖÀËÜÀÌ+ÀÌ1ÀÌWÀÌ]ÀÌmÀÌsÀÌÀÀÌÙÀÌêÀÌûÀÍÀÍ7ÀÍ8ÀÍRÀÍiÀÍjÀÍ ÀÍëÀÎÀÎKÀÎLÀÎXÀÎ{ÀÎšÀÎ¼ÀÎßÀÎãÀÎäÀÎğÀÏ"ÀÏ#ÀÏ/ÀÏ€ÀÏ‚ÀÏƒÀÏÔÀĞ#ÀĞqÀĞ½ÀĞîÀĞòÀÑ;ÀÑHÀÑsÀÑÀÀÒÀÒUÀÒ[ÀÒ¬ÀÒúÀÓ'ÀÓbÀÓzÀÓšÀÓ²ÀÓÎÀÓÏÀÔÀÔcÀÔiÀÔ´ÀÔÜÀÔâÀÔğÀÕÀÕNÀÕ}ÀÕ¬ÀÕÛÀÕåÀÕëÀÖ:ÀÖ†ÀÖŒÀÖ–ÀÖÖÀÖíÀ×À×À×2À×<À×FÀ×LÀ×^À×dÀ×…À×‹À×•À×ÓÀ×ïÀØÀØ'ÀØCÀØMÀØWÀØ]ÀØäÀØêÀØôÀÙ1ÀÙTÀÙwÀÙšÀÙ½ÀÙÇÀÙÑÀÙ×ÀÚ`ÀÚfÀÚpÀÚ±ÀÚ×ÀÚıÀÛ#ÀÛIÀÛSÀÛ]ÀÛÀÛ¤ÀÛ¿ÀÛÙÀÛ÷ÀÛøÀÜDÀÜTÀÜ|ÀÜ“ÀÜ®ÀÜÆÀÜïÀÜğÀİ>ÀİYÀİÀİ˜Àİ³ÀİËÀİôÀİõÀŞÀŞ+ÀŞJÀŞ]ÀŞ^ÀŞ—ÀŞÌÀßÀßYÀß¢Àß£ÀßÄÀßĞÀàÀàÀàGÀà\ÀàsÀà§Àà¾ÀàÈÀàğÀá	Àá(Àá?ÀáIÀá–ÀáÀÀáäÀâÀâ=ÀârÀâÀâÃÀâÉÀâÍÀâÎÀâÚÀâıÀã'Àã;Àã[Àã{Àã²ÀãÔÀãÿÀäÀäÀäÀä`ÀäaÀämÀäÀä£ÀäºÀäóÀåÀå;Àå_Àå‘ÀåµÀåçÀåöÀæÀæ!Àæ%Àæ&Àæ2ÀæHÀæ]ÀætÀæ­ÀæÆÀæõÀçÀçKÀçoÀç¡Àç°ÀèMÀèSÀèWÀèYÀèZÀè˜ÀèœÀèìÀé7Àé‰ÀéŸÀéÕÀé÷ÀêÀêNÀêbÀê£Àê§Àê¨ÀêÌÀêëÀë%Àë9ÀërÀëvÀë¥ÀëÄÀì	ÀìÀì;Àì?Àì@ÀìoÀìÀìÓÀìçÀíÀí	Àí
ÀíXÀí~Àí›ÀíœÀíÔÀîÀîfÀî²ÀîşÀï ÀïÀï4Àï8ÀïFÀïJÀï™ÀïæÀğ5Àğ]Àğ©ÀğÔÀğñÀñ-ÀñœÀñ¸ÀñÔÀñòÀòKÀòOÀòPÀò”ÀòšÀòèÀó2ÀódÀó°ÀóÍÀóğÀôÀôLÀô®Àô²Àô³ÀôıÀõÀõRÀõ‰Àõ®Àö
Àö7ÀöÀöƒÀö„ÀöÕÀ÷"À÷IÀ÷JÀ÷“À÷ËÀ÷ëÀ÷íÀ÷îÀø ÀøkÀølÀø†Àø«Àø¬ÀøÍÀùÀùÀùTÀùUÀùaÀù¤Àù¥Àù±ÀùõÀùöÀúÀú%ÀúOÀúcÀúŠÀúºÀúìÀúğÀúñÀúıÀû>Àû@ÀûAÀûyÀûİÀûŞÀûõÀüÀü'Àü(Àü<Àü~ÀüŠÀüÁÀüÂÀüİÀüôÀıÀıLÀı}Àı¨Àı®Àı²Àı³Àı¿Àş	Àş
ÀşÀşaÀşbÀşnÀş‘Àş»ÀşÏÀşüÀÿÀÿ@ÀÿgÀÿkÀÿlÀÿxÀÿªÀÿ¬Àÿ­ÀÿàÀ 1À 2À SÀ tÀ uÀ ’À ØÀ äÀÀÀ(À’À“ÀŸÀõÀöÀÀ%ÀOÀcÀ‹À·ÀäÀèÀéÀõÀ1À3À4ÀsÀwÀÇÀÀ^À”ÀÌÀÍÀ	À>À\ÀŸÀ³À÷ÀûÀWÀXÀœÀ¢ÀğÀ:ÀkÀ‰ÀÌÀîÀ,À@ÀzÀ~ÀÚÀÛÀ	À	@À	^À	¡À	µÀ	ûÀ
À
#À
|À
}À
°À
äÀÀEÀYÀ¯ÀÀ?ÀCÀ´ÀÀ(ÀEÀGÀHÀÀÃÀóÀ=ÀYÀuÀƒÀ…À†ÀÛÀôÀøÀEÀ“ÀàÀ0À4À‰ÀİÀ6ÀÀáÀ
ÀÀhÀÀ‘ÀŸÀ£ÀçÀ1ÀÀ«ÀõÀ=ÀdÀ±ÀÿÀÀTÀdÀ¾ÀÄÀÀVÀ\À´ÀÔÀÚÀ=À ÀÀÀÀ]ÀcÀ»ÀÀEÀKÀ¥ÀÀÀnÀÔÀ9ÀEÀFÀ™ÀŸÀ÷ÀOÀ¥ÀÀÀÆÀ ÀvÀ‹À‘ÀõÀYÀ¼ÀÆÀÇÀÀÀgÀÂÀÒÀØÀ 1À QÀ WÀ ºÀ!À!À!ˆÀ!ŠÀ!‹À!¼À!äÀ"À"=À"^À"oÀ"qÀ"rÀ"¦À"ÀÀ"èÀ#"À#KÀ#iÀ#ŒÀ#°À#ÓÀ#òÀ$À$À$&À$(À$)À$fÀ$ˆÀ$ªÀ$×À$ğÀ%	À%"À%;À%LÀ%NÀ%OÀ%—À%›À%íÀ& À&À&À&À&ŒÀ&À&°À&±À&æÀ&çÀ'À'"À'qÀ'ÂÀ(À(AÀ(GÀ(–À(ÌÀ(ÒÀ)5À)˜À)üÀ*bÀ*hÀ*³À*ùÀ+À+À+gÀ+ºÀ+úÀ,À,À,-À,GÀ,eÀ,À,§À,ÌÀ,ïÀ-À-/À-kÀ-~À-«À-ïÀ.,À.”À.¨À/À/À/À/ŸÀ/êÀ0
À0À0_À0°À0úÀ1/À15À1ƒÀ1¹À1¿À2"À2…À2éÀ3OÀ3UÀ3¦À3ìÀ4À4À4ZÀ4­À4íÀ4óÀ5?À5À5×À6%À6tÀ6™À6¬À6¿À6ÒÀ6ìÀ7
À72À7LÀ7_À7|À7£À7ÂÀ7ãÀ8À82À8_À8œÀ9À9À9jÀ9ÆÀ:
À: À:ŠÀ:—À; À;À;¢À;¨À;¬À<[À=CÀ=DÀ=”À=²À=¸À>À>QÀ>ŒÀ>’À>áÀ?2À?|À?±À?·À@À@HÀ@NÀ@°ÀAÀAuÀAÚÀAàÀB/ÀBÀB¢ÀB¨ÀBõÀCHÀCˆÀCšÀC­ÀCÇÀCåÀDÀD*ÀDMÀDgÀDÀD­ÀDÎÀDñÀEÀE8ÀEtÀE‡ÀE´ÀEñÀFYÀFmÀFâÀFæÀG§ÀG¨ÀGúÀHÀH6ÀHÀH›ÀHÉÀI%ÀI+ÀI/ÀI1ÀI2ÀIpÀI“ÀIãÀJ/ÀJ{ÀJÌÀKÀKpÀKšÀK¶ÀLÀL&ÀL-ÀLoÀLˆÀL¡ÀL¾ÀLÎÀLìÀM*ÀM>ÀM›ÀMŸÀM×ÀN^ÀN`ÀNaÀNÑÀNÕÀOÀOPÀOTÀOÌÀOĞÀP	ÀP
ÀPNÀPTÀP¢ÀPñÀQÀQ!ÀQÀQâÀRÀR,ÀRIÀRPÀR³ÀR·ÀR¸ÀRÔÀRêÀS	ÀS&ÀS-ÀSAÀSwÀS„ÀS£ÀSªÀSÍÀT ÀT)ÀT-ÀT.ÀTSÀTsÀTtÀT°ÀTúÀTûÀUFÀU`ÀUfÀU±ÀUåÀUëÀV5ÀVvÀV|ÀVÍÀWÀWPÀWVÀW‰ÀWÀW™ÀWÆÀWòÀXÀXLÀXVÀX\ÀX«ÀXôÀXúÀYXÀY^ÀY‰ÀYÀYšÀYªÀY½ÀYøÀYşÀZYÀZœÀZ¢ÀZÕÀZÛÀZåÀ[À[GÀ[QÀ[WÀ[ À[¬À[²À[ıÀ\:À\LÀ\lÀ\”À\›À\¼À\óÀ\ùÀ]/À]JÀ]¾À]ÄÀ^)À^wÀ^}À^ À^ÉÀ^ÖÀ_À_À_KÀ_À_ÅÀ_ØÀ_ÜÀ_İÀ_íÀ`	À`(À`OÀ`tÀ`vÀ`wÀ`‘À`¸ÀaÀaÀa#ÀaaÀatÀa‡Àa Àa»ÀaÌÀaÍÀaïÀbÀb?Àb@ÀbLÀboÀbÀb¢ÀbÌÀbàÀcÀc*ÀcoÀc¾ÀcÂÀcÃÀcÏÀd1Àd3Àd4Àd…Àd‰Àd¬ÀdóÀeÀeMÀeZÀe[Àe©ÀeºÀe»ÀfÀf*Àf,Àf-ÀfeÀf—ÀfŞÀfäÀg"ÀgmÀgsÀgÄÀgíÀgóÀh.ÀhWÀhÀhØÀhŞÀi+ÀiUÀišÀi¦Ài»ÀiÙÀiÿÀjÀj0ÀjMÀjpÀjÅÀkÀkYÀk¤Àk÷ÀlSÀlTÀlšÀlêÀmÀm%ÀmYÀmzÀmˆÀm¿ÀmäÀmòÀmóÀnaÀn£Àn§Àn¨ÀnøÀo,ÀohÀo¢ÀoãÀoéÀpÀpÀpfÀp«ÀpÆÀpÌÀqÀqfÀqyÀq´ÀqİÀrÀr^ÀrdÀrµÀs ÀsÀsÀsZÀs„ÀsÉÀsÙÀsîÀtÀt0ÀtGÀt`Àt}Àt ÀtõÀuLÀuÀuØÀv+Àv‡ÀvˆÀvÚÀwÀw Àw!ÀwDÀw[ÀwÀw­ÀwÍÀxÀx	Àx
ÀxXÀx\Àx}ÀxÁÀxÒÀxôÀxúÀyHÀy’ÀyËÀyÑÀzÀzmÀzƒÀzÀzÀzÈÀzÎÀ{À{À{\À{rÀ{{À{|À{±À{·À{ùÀ|À|À|À|À|gÀ|sÀ|wÀ|–À|¤À|ÜÀ|êÀ|ëÀ}$À}1À}3À}4À}iÀ}mÀ}´À}øÀ~9À~=À~†À~ÖÀÀ<À@ÀÀÙÀ€À€À€_À€À€ÎÀÀ/À5À~ÀÆÀ‚À‚eÀ‚²À‚õÀ‚ûÀƒBÀƒXÀƒtÀƒÈÀƒæÀ„CÀ„]À„|À„›À„õÀ„ùÀ…'À…HÀ…hÀ…ŠÀ…ÊÀ…ËÀ†)À†…À†ÊÀ†èÀ†éÀ‡1À‡7À‡cÀ‡iÀ‡yÀ‡À‡ĞÀˆÀˆ)Àˆ*Àˆ{ÀˆÌÀ‰À‰dÀ‰sÀ‰yÀ‰ÅÀŠÀŠdÀŠ¬ÀŠúÀ‹DÀ‹JÀ‹—À‹À‹ÁÀ‹ÇÀŒÀŒaÀŒ±ÀÀ&À,ÀzÀÃÀÀbÀ°À ÀHÀuÀ{ÀÅÀŞÀäÀòÀÀGÀ^À¢ÀËÀ‘À‘CÀ‘]À‘wÀ‘À‘‰À‘À‘ŞÀ’,À’zÀ’˜À’À’¬À’ÙÀ“À“DÀ“[À“ŸÀ“ÚÀ”À”1À”9À”CÀ”IÀ”šÀ”àÀ•*À•0À•>À•kÀ•‚À•ÚÀ–À–1À–HÀ–­À–êÀ—À—À—À—À—gÀ—°À˜À˜9À˜?À˜cÀ˜iÀ˜¨À˜®À˜üÀ™JÀ™›À™æÀš5ÀšƒÀšÎÀ›À›jÀ›»À›ÖÀ›ÜÀ›ìÀ›òÀœBÀœdÀœ¬ÀœÂÀœğÀÀ%ÀaÀnÀ’ÀÙÀÀÀÀbÀÀ¯ÀÍÀíÀŸÀŸ=ÀŸ~ÀŸÀŸ¿ÀŸŞÀŸäÀ #À )À wÀ »À åÀ æÀ¡)À¡nÀ¡µÀ¡êÀ¡ğÀ¢À¢HÀ¢IÀ¢™À¢éÀ£+À£,À£{À£ÅÀ£ÖÀ£ÜÀ¤"À¤4À¤sÀ¤tÀ¤¯À¤°À¥À¥;À¥<À¥À¥ÙÀ¦(À¦QÀ¦‰À¦ŠÀ¦ÚÀ§À§=À§ZÀ§xÀ§¶À§ÏÀ§ÓÀ¨À¨À¨dÀ¨{À¨À¨ÅÀ¨ËÀ©À©eÀ©À©”À©ŞÀ©òÀªNÀªnÀªŠÀª«À«À«À«%À«BÀ«aÀ«À«À«ÛÀ«ÜÀ¬*À¬IÀ¬OÀ¬“À¬™À¬ëÀ­3À­ƒÀ­¾À­àÀ®À®3À®7À®‰À®ŠÀ®ØÀ®ìÀ®òÀ¯6À¯<À¯À¯ÖÀ¯ÿÀ°7À°wÀ°˜À°ºÀ°¾À±À±À±JÀ±–À±³À±èÀ²À²"À²PÀ²TÀ²›À²œÀ²ëÀ³3À³9À³‡À³¼À³ÜÀ³üÀ´À´_À´cÀ´À´›À´·À´ÓÀµÀµ@ÀµAÀµpÀµvÀµ»ÀµÖÀµöÀ¶À¶>À¶BÀ¶ À¶¡À¶ñÀ·,À·VÀ·vÀ·‘À·ÍÀ·ùÀ·ıÀ¸À¸8À¸WÀ¸wÀ¸¥À¸äÀ¸åÀ¹6À¹xÀ¹¥À¹ÇÀ¹âÀº$Àº(ÀºMÀº|Àº½Àº¾À»À»^À»„À»ŠÀ»ÏÀ¼
À¼,À¼NÀ¼iÀ¼ÁÀ¼ÅÀ¼ëÀ½À½AÀ½„À½…À½ÒÀ¾#À¾FÀ¾pÀ¾À¾«À¾çÀ¿À¿À¿5À¿RÀ¿qÀ¿‘À¿¿À¿şÀ¿ÿÀÀJÀÀœÀÀëÀÁÀÁHÀÁgÀÁ‚ÀÁÄÀÁÈÀÁåÀÂÀÂ$ÀÂTÀÂ—ÀÂ˜ÀÂÔÀÂÚÀÃÀÃgÀÃ±ÀÄÀÄVÀÄ¦ÀÄÒÀÄØÀÅ0ÀÅÀÅ¯ÀÅÊÀÆÀÆSÀÆWÀÆtÀÆÀÆ®ÀÆÍÀÆğÀÇÀÇ3ÀÇ`ÀÇÀÇÀÇÓÀÇÙÀÈ"ÀÈkÀÈ—ÀÈÁÀÉÀÉÀÉNÀÉRÀÉnÀÉœÀÉÛÀÉÜÀÊ*ÀÊÀÊ½ÀÊÿÀË#ÀË>ÀËªÀË®ÀËÎÀËêÀÌÀÌ5ÀÌ[ÀÌ ÀÌ¡ÀÌğÀÍ<ÀÍBÀÍ‘ÀÍªÀÍ°ÀÍüÀÎEÀÎXÀÎÀÎßÀÎşÀÏÀÏ8ÀÏYÀÏvÀÏ’ÀÏ°ÀÏÏÀÏìÀĞÀĞ&ÀĞEÀĞhÀĞˆÀĞ·ÀĞ»ÀĞßÀÑÀÑ*ÀÑQÀÑyÀÑŸÀÑÄÀÑëÀÒÀÒFÀÒpÀÒ½ÀÒ¾ÀÓÀÓÀÓYÀÓ§ÀÓôÀÔAÀÔ„ÀÔŠÀÔØÀÕ%ÀÕsÀÕºÀÕËÀÖÀÖUÀÖwÀÖ–ÀÖ±ÀÖÒÀÖòÀ×À×2À×TÀ×qÀ×À×«À×ÊÀ×íÀØÀØ<ÀØ@ÀØdÀØÀØµÀØßÀÙ
ÀÙ0ÀÙUÀÙ|ÀÙ¤ÀÙ×ÀÚÀÚNÀÚOÀÚ–ÀÚ¯ÀÚÕÀÛÀÛ6ÀÛ:ÀÛ|ÀÛ}ÀÛÉÀÛÙÀÛßÀÜ*ÀÜ7ÀÜ=ÀÜ‰ÀÜÖÀİÀİÀİiÀİµÀİ»ÀŞÀŞYÀŞ¦ÀŞ¬ÀŞöÀßBÀßÀßÊÀßéÀàÀà?ÀàCÀàDÀà‰ÀàÀàÖÀàÜÀàìÀàòÀáBÀá[Àá¦ÀáÅÀááÀáüÀâUÀâYÀâZÀâŸÀâ¥ÀâõÀãBÀãHÀãXÀã^Àã¬ÀãÊÀäÀä6ÀäRÀämÀäÀäØÀåÀå#Àå$ÀåTÀå{ÀåÀåàÀåáÀæÀæÀæ_Àæ¡ÀæïÀç'ÀçqÀç±ÀçÒÀç÷ÀèGÀè|Àè‚Àè©Àè¯Àè¿ÀéÀé\ÀéƒÀéÕÀê Àê!ÀêiÀê„Àê£ÀêîÀêòÀëÀë>ÀëpÀë·Àë¸ÀëüÀìÀìSÀì¬ÀìÿÀíSÀí‹Àí‘ÀíáÀî2ÀîÀîÓÀï#ÀïwÀïÃÀïÉÀğÀğjÀğ¿ÀñÀñFÀñšÀñèÀò,Àò2Àò…ÀòÔÀóÀómÀóÂÀóÈÀôÀômÀô¶Àô¼ÀõÀõ(Àõ.Àõ<ÀõQÀõdÀõ|Àõ”ÀõœÀõ¢ÀõĞÀö)ÀöGÀöhÀönÀö€Àö¯ÀöĞÀ÷À÷5À÷_À÷~À÷šÀ÷×À÷õÀøÀøYÀø…Àø±ÀøÂÀø×ÀùÀùHÀùoÀùyÀùÀù‹Àù“ÀùÀù£ÀùüÀúÀúÀú%Àú8ÀúPÀúhÀú{Àú”ÀúœÀú¢ÀúĞÀû)ÀûGÀûhÀûnÀû€Àû¯ÀûĞÀüÀü5Àü_ÀüŠÀü¦ÀüãÀıÀıÀıeÀı‘Àı½ÀıÎÀıãÀşÀşTÀşjÀş˜ÀşÌÀşøÀÿÀÿÀÿÀÿÀÿ&Àÿ,ÀÿuÀÿÀÀÿóÀÿùÀ 	À À ]À tÀ ’À ÁÀ äÀ
À1ÀRÀrÀ´ÀÔÀïÀ2ÀMÀNÀvÀÀéÀ4ÀœÀÀäÀ#À$ÀNÀnÀ“À¸ÀİÀÀ5ÀWÀÀÃÀ÷À+ÀQÀvÀÀÅÀËÀÌÀ5ÀvÀ®À¯À¿ÀÀdÀkÀoÀpÀ´ÀºÀ	À	dÀ	·À
À
]À
¯À
æÀ
ìÀ<À„ÀŠÀÛÀÀFÀLÀšÀäÀêÀ6ÀƒÀÓÀÙÀ4ÀEÀKÀYÀnÀÀ™À±À¹À¿ÀíÀFÀdÀ…À‹ÀÀÌÀÀkÀ¼ÀØÀÀgÀŸÀÛÀÀ+À[ÀƒÀ‰ÀâÀ=À—ÀÙÀÀ1ÀnÀ«À·ÀØÀ3À=ÀCÀOÀWÀaÀgÀÀÀÆÀÔÀéÀüÀÀ,À?ÀXÀ`ÀfÀ”ÀíÀÀ,À2ÀDÀsÀÃÀÀcÀÀÄÀÀLÀ„ÀÀÀéÀÀ@ÀhÀnÀÉÀ À{ÀØÀ#ÀiÀ’À¬ÀçÀÀÀcÀÀ·ÀÆÀıÀ4ÀiÀÀ¤ÀşÀXÀ°À÷À &À 2À SÀ ¾À ÈÀ ÎÀ ÚÀ âÀ ìÀ òÀ!À!À!UÀ!jÀ!‹À!ºÀ!áÀ"À"2À"VÀ"yÀ"»À"ŞÀ"ùÀ#*À#EÀ#FÀ#nÀ#™À#çÀ$À$aÀ$›À%À%LÀ%MÀ%]À%²À%üÀ&À&À&À&7À&]À&‡À&§À&ÔÀ&ùÀ'À'?À'ƒÀ'„À'ÑÀ'×À('À(<À(BÀ(hÀ(ÀÀ) À)À)DÀ)ˆÀ)ŒÀ)ªÀ)ÈÀ)íÀ*6À*8À*9À*À*…À*¹À*½À+À+FÀ+ˆÀ+¢À+ÓÀ,À,9À,?À,uÀ,‘À, À,¡À,ËÀ,ÑÀ- À-oÀ-¸À-¾À.
À.NÀ.À.—À.ºÀ.îÀ/À/TÀ/qÀ/‹À/œÀ/ÀÀ/ÊÀ/ÔÀ/ÛÀ/ßÀ/àÀ0AÀ0BÀ0’À0µÀ0ÈÀ0àÀ0ğÀ1À1À1%À15À19À1:À1fÀ1gÀ1hÀ1‚À1ÈÀ1ÎÀ2À22À2MÀ2aÀ2qÀ2À2 À2ªÀ3À3À3À3hÀ3nÀ3¿À3ñÀ44À46À47À4~À4‚À4ÇÀ5À5EÀ5†À5ÍÀ5éÀ6À6-À6iÀ6jÀ6¥À6«À6ïÀ76À7mÀ7²À7îÀ8À8À8IÀ8OÀ8šÀ8êÀ9/À9JÀ9cÀ9§À9ĞÀ9ìÀ:À:À:3À:7À:8À:ˆÀ:‰À:œÀ:À:ŸÀ:´À:¸À:ôÀ;À;À;#À;nÀ;¹À;ÓÀ;ÙÀ<À< À<oÀ<ˆÀ<™À<ÇÀ<æÀ=À=>À=}À=ÒÀ=ÓÀ>À>'À>QÀ>|À>£À>ÊÀ>ôÀ>õÀ?%À?+À?}À? À?µÀ?¶À?õÀ?ûÀ@IÀ@•À@×À@îÀ@ïÀAAÀA\ÀA]ÀAÀA•ÀAÈÀAÎÀAûÀBnÀB¤ÀBØÀBÜÀBİÀCÀCÀCRÀCÀCÀCÜÀCâÀDÀDnÀD•ÀD›ÀDßÀE(ÀEwÀE™ÀE­ÀEÀÀEÖÀFÀFÀFÀFpÀF~ÀFÀF±ÀFÅÀFäÀGÀGÀGÀGÀGGÀGMÀG˜ÀGİÀHÀHÀH-ÀHzÀHÄÀIÀI[ÀI©ÀIùÀJFÀJŠÀJÀJßÀJÿÀKÀKLÀKcÀKxÀKÀK¤ÀK³ÀKÔÀKÜÀKéÀL ÀLÀL*ÀLAÀLtÀL«ÀLíÀLøÀM ÀMÀM
ÀMÀMDÀMJÀM’ÀM˜ÀM»ÀN	ÀN ÀN@ÀNSÀNiÀNÀN«ÀNæÀOÀOCÀOxÀOŸÀOÔÀOõÀPÀPÀPÀPÀP<ÀP\ÀPoÀPŠÀPªÀPÌÀP÷ÀPûÀPüÀQÀQEÀQFÀQ’ÀQäÀR ÀR:ÀRSÀRmÀRnÀR«ÀRáÀRâÀRüÀSIÀS{ÀSØÀT5ÀTYÀTuÀT¬ÀT­ÀTèÀU1ÀU2ÀUkÀUšÀU›ÀUÔÀVÀVÀVUÀV‘ÀV¹ÀVÁÀVÇÀVÈÀVàÀVäÀVåÀVñÀW4ÀW6ÀW7ÀW~ÀW‚ÀWÑÀWçÀX ÀXBÀXCÀX‘ÀX¦ÀXçÀY,ÀY^ÀY„ÀY¢ÀY¦ÀYüÀYıÀZ1ÀZEÀZFÀZeÀZfÀZÀZ•ÀZæÀ[À[À[)À[JÀ[]À[gÀ[|À[€À[À[ÑÀ[ôÀ[úÀ\GÀ\‘À\ŞÀ]+À]yÀ]—À]ªÀ]ºÀ]ÙÀ]öÀ^	À^À^#À^'À^(À^\À^^À^_À^ªÀ^®À^ıÀ_À_NÀ_eÀ_fÀ_±À_ôÀ`0À`bÀ`šÀ`ºÀ`¾Àa-Àa.ÀagÀamÀa¹ÀaÉÀaÏÀbÀbpÀb±ÀbîÀcÀc#Àc;ÀcTÀcgÀcÀc”Àc¨Àc¾ÀdÀdÀdiÀdmÀeÀeÀeÀeNÀexÀe~Àe¹ÀeäÀeåÀeõÀf)ÀfTÀfZÀf•ÀfÃÀfÄÀfÛÀgÀgOÀgUÀgŒÀgÏÀgĞÀh ÀhCÀhvÀhwÀhÅÀháÀhçÀi2ÀiÀiÀi–ÀiäÀjÀj\ÀjÀj©Àj¯ÀjäÀjÿÀkÀkÀk=ÀkXÀkuÀk³ÀkòÀlÀlSÀltÀlªÀl°ÀlÑÀlóÀlôÀmÀmRÀmdÀmhÀmßÀmáÀmâÀnÀnGÀnHÀn€Àn„ÀnÎÀnÛÀoÀoÀooÀo…Ào‰Ào×ÀoõÀoùÀpFÀpJÀp]ÀpaÀpmÀp¢Àp¦ÀpáÀqÀq#Àq'ÀqGÀqxÀq~Àq†ÀqáÀr=ÀroÀr£ÀrÙÀs ÀsdÀs¡ÀsµÀsáÀsöÀtÀt5ÀtDÀt„ÀtŒÀt™Àt¶Àt¼ÀtÂÀtÒÀtçÀuÀuÀu      =¥